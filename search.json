[{"title":"Idea破解方法","url":"/2022/09/09/Idea破解方法/","content":"\n<font color=red>通过补丁可以永久激活 IDEA，前面 IDEA 安装方式都是一样的，主要是后面的步骤，注意看后面就行~</font>\n\n申明：本教程 IntelliJ IDEA 破解补丁、激活码均收集于网络，请勿商用，仅供个人学习使用，如有侵权，请联系作者删除。若条件允许，希望大家购买正版 ！\n\nPS: 本教程最新更新时间: 2022年09月09日~\n\nidea安装教程和冲突笔者不在这里赘述，百度都有解决方案，咱们直接开始后面的步骤~~~~\n\n# 一、 永久激活版\n- ### 下载激活脚本\n   ![Reference](破解文件列表.png)\n  打开文件夹后，目录如下，ja-netfilter.jar 为激活补丁：\n  ![Reference](ja-netifilter.png)\n- ### 复制补丁所在的整个文件夹到硬盘某个位置\n  <font color=red>必须是整个ja-netifilter文件夹，之后就不要移动和删除这个文件夹了,这里笔者是直接放在了D盘</font>\n- ### 引用激活补丁\n  进入 IDEA 的安装目录，笔者安装时，使用了默认安装路径，然后，进入 /bin 目录下，修改\n    `idea64.exe.vmoptions`配置文件:\n  ![Reference](idea64.exe.vmoptions.png)\n  在 `idea64.exe.vmoptions` 配置文件结尾添加如下配置：\n    ``` vmoptions\n    # 引用补丁，开头必须以 -javaagent: 开头，后面跟着补丁的绝对路径（可根据你实际的位置进行修改）,注意路径一定要填写正确，且不能包含中文，否则会导致 IDEA 无法启动\n    -javaagent:D:/ja-netfilter/ja-netfilter.jar\n    # 最新 IDEA 版本需要添加下面两行，以支持 Java 17, 否则会报 Key is invalid\n    --add-opens=java.base/jdk.internal.org.objectweb.asm=ALL-UNNAMED\n    --add-opens=java.base/jdk.internal.org.objectweb.asm.tree=ALL-UNNAMED\n    ```\n  ![Reference](vmoptions配置文件编辑.png)\n- 重启 IDEA\n\n  <font color=red>配置完成后保存，一定要重启 IDEA !!!</font>\n\n  <font color=red>配置完成后保存，一定要重启 IDEA !!!</font>\n- 重新打开 IDEA, 填入指定激活码点击激活完成激活\n  ```\n  ZCB571FZHV-eyJsaWNlbnNlSWQiOiJaQ0I1NzFGWkhWIiwibGljZW5zZWVOYW1lIjoiZnV6emVzIGFsbHkiLCJhc3NpZ25lZU5hbWUiOiIiLCJhc3NpZ25lZUVtYWlsIjoiIiwibGljZW5zZVJlc3RyaWN0aW9uIjoiIiwiY2hlY2tDb25jdXJyZW50VXNlIjpmYWxzZSwicHJvZHVjdHMiOlt7ImNvZGUiOiJQREIiLCJmYWxsYmFja0RhdGUiOiIyMDIzLTA3LTAxIiwicGFpZFVwVG8iOiIyMDIzLTA3LTAxIiwiZXh0ZW5kZWQiOnRydWV9LHsiY29kZSI6IlBTSSIsImZhbGxiYWNrRGF0ZSI6IjIwMjMtMDctMDEiLCJwYWlkVXBUbyI6IjIwMjMtMDctMDEiLCJleHRlbmRlZCI6dHJ1ZX0seyJjb2RlIjoiUFBDIiwiZmFsbGJhY2tEYXRlIjoiMjAyMy0wNy0wMSIsInBhaWRVcFRvIjoiMjAyMy0wNy0wMSIsImV4dGVuZGVkIjp0cnVlfSx7ImNvZGUiOiJQQ1dNUCIsImZhbGxiYWNrRGF0ZSI6IjIwMjMtMDctMDEiLCJwYWlkVXBUbyI6IjIwMjMtMDctMDEiLCJleHRlbmRlZCI6dHJ1ZX0seyJjb2RlIjoiUFBTIiwiZmFsbGJhY2tEYXRlIjoiMjAyMy0wNy0wMSIsInBhaWRVcFRvIjoiMjAyMy0wNy0wMSIsImV4dGVuZGVkIjp0cnVlfSx7ImNvZGUiOiJQUkIiLCJmYWxsYmFja0RhdGUiOiIyMDIzLTA3LTAxIiwicGFpZFVwVG8iOiIyMDIzLTA3LTAxIiwiZXh0ZW5kZWQiOnRydWV9LHsiY29kZSI6IklJIiwiZmFsbGJhY2tEYXRlIjoiMjAyMy0wNy0wMSIsInBhaWRVcFRvIjoiMjAyMy0wNy0wMSIsImV4dGVuZGVkIjpmYWxzZX0seyJjb2RlIjoiUEdPIiwiZmFsbGJhY2tEYXRlIjoiMjAyMy0wNy0wMSIsInBhaWRVcFRvIjoiMjAyMy0wNy0wMSIsImV4dGVuZGVkIjp0cnVlfSx7ImNvZGUiOiJQU1ciLCJmYWxsYmFja0RhdGUiOiIyMDIzLTA3LTAxIiwicGFpZFVwVG8iOiIyMDIzLTA3LTAxIiwiZXh0ZW5kZWQiOnRy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\n  ```\n- 成功页面\n\n![Reference](激活成功页面.png)\n\n# 二、 30天无限试用插件版\n- 将ide-eval-resetter-2.1.6插件包直接拖进idea中安装然后重启idea\n\n  ![Reference](ide-eval-resetter-2.1.6.png)\n\n  ![Reference](ide-eval启用.png)\n- 接着点击该插件的reset重置即可试用30天\n## 附破解包from百度网盘:\n## [破解包](https://pan.baidu.com/s/1YTc2CFHbSXz8Jbvo_S9_Jw  \"JetBrains2022最新全家桶激活(7.30).zip\") 密码:18cm\n","tags":["软件分享","Idea","破解"],"categories":["杂七杂八","软件安利"]},{"title":"Hello World","url":"/2022/09/09/hello-world/","content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n"},{"title":"Java-引用","url":"/2022/09/06/Java-引用/","content":"\n# 数据类型\n\nJava里将数据类型分为了基本数据类型和引用数据类型，基本数据类型包含: byte、char、short、int、float、double、long、boolean，剩下的都是引用类型。最常用的就是String字符串：\n- 基本数据类型的值都是直接保存在变量中的(一个变量一个值，可以体会到类似Integer.valueof缓存值的用意)\n- 而引用类型的变量类似于C语言的指针，它内部存储一个“地址”，指向某个对象在内存的位置\n- 对于基本类型变量num，赋值运算符将会直接修改变量的值，原来的数据将被覆盖掉，被替换为新的值。\n- 对于引用类型变量str，赋值运算符只会改变变量中所保存的**对象的地址**信息，原来对象的地址被覆盖掉，重新写入新对象的地址数据。但**原来的对象本身并不会被改变**，只是不再被任何引用所指向的对象，即“垃圾对象”，后续会被垃圾回收器回收。\n- 引用类型的变量可以指向一个空值null，它表示不存在，即该变量不指向任何对象\n\n基本类型的变量是“持有”某个数值，引用类型的变量是“指向”某个对象\n\n<!-- more -->\n\n``` java\n    public static void main(String[] args) {\n        int num = 1;\n        int num2 = num;\n        System.out.println(\"num修改前: \" + num + \" num2: \" + num2);\n        num = 2;\n        System.out.println(\"num修改后: \" + num + \" num2: \" + num2);\n\n        System.out.println(\"=======================\");\n        StringBuilder sb =  new StringBuilder(\"hello\");\n        StringBuilder sb2 = sb;\n        System.out.println(\"sb修改前: \" + sb.toString() + \" sb2: \" + sb2.toString());\n        sb.append(\" world\");\n        System.out.println(\"sb修改后: \" + sb.toString() + \" sb2: \" + sb2.toString());\n\n        System.out.println(\"=======================\");\n        String str = \"hello\";\n        String str2 = str;\n        System.out.println(\"str修改前: \" + str + \" str2: \" + str2);\n        str = \"world\";\n        System.out.println(\"str修改后: \" + str + \" str2: \" + str2);\n\n    }\n\n\n//输出\nnum修改前: 1 num2: 1\nnum修改后: 2 num2: 1\n=======================\nsb修改前: hello sb2: hello\nsb修改后: hello world sb2: hello world\n=======================\nstr修改前: hello str2: hello\nstr修改后: world str2: hello\n```\n\n> 这里可以联想下String的不可变性\n\n## 参数传递\n\nJava的参数传递为值传递。也就是说，当我们传递一个参数时，方法将获得该参数的一个拷贝:\n\n- 基本类型变量的值传递，意味着变量本身被复制，并传递给Java方法。Java方法对变量的修改不会影响到原变量。\n- 引用的值传递，意味着对象的地址被复制，并传递给Java方法。Java方法根据该引用的访问将会影响对象\n\n``` Java\npublic class Test {\n\n    public static void main(String[] args) {\n        int num = 1;\n        System.out.println(\"num修改前: \" + num);\n        testIntArg(num);\n        System.out.println(\"num修改后: \" + num);\n\n        System.out.println(\"=======================\");\n        StringBuilder sb =  new StringBuilder(\"hello\");\n        System.out.println(\"sb修改前: \" + sb.toString());\n        testSbArg(sb);\n        System.out.println(\"sb修改后: \" + sb.toString());\n\n        System.out.println(\"=======================\");\n        String str = \"hello\";\n        System.out.println(\"str修改前: \" + str);\n        testStrArg(str);\n        System.out.println(\"str修改后: \" + str);\n\n    }\n\n    public static void testIntArg(int num) {\n        //基本数据类型，参数传递后，方法内部修改不会影响原有参数\n        System.out.println(\"testIntArg, num修改前: \" + num);\n        num = 2;\n        System.out.println(\"testIntArg,num修改后: \" + num);\n    }\n\n    public static void testSbArg(StringBuilder sb) {\n        //引用数据类型，参数传递后，除非重新new对象，否则方法内部修改会影响原有参数\n        System.out.println(\"testSbArg, sb修改前: \" + sb.toString());\n        sb.append(\" world\");\n        System.out.println(\"testSbArg, sb修改后: \" + sb.toString());\n    }\n\n    public static void testStrArg(String str) {\n        System.out.println(\"testStrArg, str修改前: \" + str);\n        //String 这里就相当于new String()了\n        str = \"hello world\";\n        System.out.println(\"testStrArg, str修改后: \" + str);\n    }\n\n}\n\n//输出\nnum修改前: 1\ntestIntArg, num修改前: 1\ntestIntArg,num修改后: 2\nnum修改后: 1\n=======================\nsb修改前: hello\ntestSbArg, sb修改前: hello\ntestSbArg, sb修改后: hello world\nsb修改后: hello world\n=======================\nstr修改前: hello\ntestStrArg, str修改前: hello\ntestStrArg, str修改后: hello world\nstr修改后: hello\n```\n\n# 引用类型\n\n\nJava提供了四种引用类型：强引用(FinalReference)、软引用(SoftReference)、弱引用(WeakReference)、虚引用(PhantomReference)\n\n![Reference](Reference.png)\n\n除了强引用(FinalReference)其他都是public修饰的，可以在我们的程序里直接使用，事实如果我们直接定义变量等某个对象时，默认就是对这个对象的强引用\n\n## 强引用\n\n强引用特点：\n\n- 强引用可以直接访问目标对象\n- 只要有引用变量存在，垃圾回收器永远不会回收。JVM即使抛出OOM异常，也不会回收强引用所指向的对象。\n+ 强引用可能导致内存泄漏问\n\n强引用是使用最普遍的引用。如果一个对象具有强引用，那么垃圾回收器**绝不会回收**它。例如:StringBuilder sb = new StringBuilder(\"test\");变量str指向StringBuffer实例所在的堆空间，通过str可以操作该对象。\n\n在不用对象的时将引用赋值为 null，能够帮助垃圾回收器回收对象(具体回收时机还是要看垃圾收集策略)。比如 ArrayList 的 clear() 方法实现：\n\n``` Java\n    public void clear() {\n        modCount++;\n        final Object[] es = elementData;\n        for (int to = size, i = size = 0; i < to; i++)\n            es[i] = null;\n    }\n```\n\n## 软引用\n\n软引用是用来描述一些有用但并不是必需的对象。对于软引用关联着的对象，在系统将要发生内存溢出异常之前，将会把这些对象列进回首范围之中进行第二次回收。如果这次回收还没有足够的内存，才会抛出内存溢出异常。\n\n因此，软引用可以用于实现**对内存敏感的高速缓存**: 在内存足够的情况下直接通过软引用取值，无需从的真实来源查询数据，提升速度；当内存不足时，自动删除这部分缓存数据，从真正的来源查询这些数据。\n\n软引用特点是它的一个实例保存对一个Java对象的软引用，该软引用的存在不妨碍垃圾收集线程对该Java对象的回收：\n- 在垃圾线程对这个Java对象回收前，SoftReference类所提供的get()方法返回Java对象的强引用\n- 在垃圾线程回收该Java对象之后，get()方法将返回null\n\n> 软引用对象是在jvm内存不够的时候才会被回收\n\n``` Java\npublic class SoftReferenceTest {\n\n    static class HeapObject {\n        byte[] bs = new byte[1024 * 1024];\n    }\n\n    public static void main(String[] args) {\n        SoftReference<HeapObject> softReference = new SoftReference<>(new HeapObject());\n\n        List<HeapObject> list = new ArrayList<>();\n\n        while (true) {\n            if (softReference.get() != null) {\n                //模拟消耗内存\n                list.add(new HeapObject());\n                System.out.println(\"list.add\");\n            } else {\n                System.out.println(\"---------软引用已被回收---------\");\n                break;\n            }\n            System.gc();\n        }\n    }\n}\n```\n\n实现简易版缓存\n\n``` Java\n/**\n * 简易版软引用实现的缓存\n */\npublic class SoftReferenceCache<K, V> {\n    private final HashMap<K, SoftReference<V>> mCache;\n\n    public SoftReferenceCache() {\n        mCache = new HashMap<K, SoftReference<V>>();\n    }\n\n    /**\n     * 将对象放进缓存中，这个对象可以在GC发生时被回收\n     * @param key key的值.\n     * @param value value的值型.\n     */\n    public void put(K key, V value) {\n        mCache.put(key, new SoftReference<V>(value));\n    }\n\n    /**\n     * 从缓存中获取value\n     * @param key\n     * @return 如果找到的话返回value，如果被回收或者没有就返回null\n     */\n    public V get(K key) {\n        V value = null;\n        SoftReference<V> reference = mCache.get(key);\n        if (reference != null) {\n            value = reference.get();\n        }\n\n        return value;\n    }\n}\n\n```\n\n## 弱引用\n\n弱引用是一种比软引用较弱的引用类型。在系统GC时，只要发现弱引用，不管系统堆空间是否足够，都会将对象进行回收。\n\n不过，由于垃圾回收器是一个优先级很低的线程，因此不一定会很快发现那些只具有弱引用的对象。弱引用主要用于监控对象是否已经被垃圾回收器标记为即将回收的垃圾，可以通过弱引用的isEnQueued方法返回对象是否被垃圾回收器标记。\n\n``` Java\n    public static void main(String[] args) {\n        String str = new String(\"abc\");\n        WeakReference<String> weakReference = new WeakReference<>(str);\n        System.out.println(\"1str: \" + str + \" weakReference>>: \" + weakReference.get());\n        str = null;\n        System.out.println(\"2str: \" + str + \" weakReference>>: \" + weakReference.get());\n        System.gc();\n        System.out.println(\"3str: \" + str + \" weakReference>>: \" + weakReference.get());\n    }\n\n//输出\n1str: abc weakReference>>: abc\n2str: null weakReference>>: abc\n3str: null weakReference>>: null\n```\n\n如果一个对象是偶尔(很少)的使用，并且希望在使用时随时就能获取到，但又不想影响此对象的垃圾收集，那么你应该用Weak Reference来记住此对象\n\n> Java中的ThreadLocal内部实现使用的就是WeakReference，因为weakReference的值可能为空，故在使用ThreadLocal时可以使用其提供的initialValue方法\n\n## 软引用VS弱引用\n\n软引用关联的对象只有在内存不足时才会被回收，而被弱引用关联的对象在JVM进行垃圾回收时总会被回收。\n\n``` Java\n/**\n * 软引用测试类\n * jvm参数， -Xms5m -Xmx10m表示初始内存是5M，最大内存是10M\n * -Xmx256m\n * @author jone.sun\n * @date 2020-11-30 11:12\n */\npublic class ReferenceTest {\n\n    private static List<Object> list = new ArrayList<>();\n\n    private static final Integer COUNT = 10;\n\n    public static void main(String[] args) {\n//        testFinalReference();\n//        testSoftReference();\n        testWeakReference();\n\n        print();\n        //手动调用gc\n        System.gc();\n        System.out.println(\"调用gc后\");\n        print();\n    }\n\n    /**\n     * 测试强引用\n     */\n    private static void testFinalReference() {\n        list.clear();\n        //我本机测试时 count为3就会报java.lang.OutOfMemoryError: Java heap space\n        for (int i = 0; i < COUNT; i++) {\n            //每次申请1M\n            list.add(new byte[1024 * 1024]);\n        }\n        System.out.println(\"list: \" + list.size());\n\n    }\n\n\n    /**\n     * 测试软引用\n     */\n    private static void testSoftReference() {\n        list.clear();\n        //可以随机添加，但最多只会保留两个，其他会被设置为null\n        for (int i = 0; i < COUNT; i++) {\n            byte[] buff = new byte[1024 * 1024];\n            SoftReference<byte[]> sr = new SoftReference<>(buff);\n            //注意这里是将data置为null之后，否则data是存在强引用关系的，软引用亦是如此。\n            buff = null;\n            list.add(sr);\n        }\n        System.out.println(\"list: \" + list.size());\n    }\n\n    /**\n     * 测试弱引用\n     */\n    private static void testWeakReference() {\n        list.clear();\n        //可以随机添加，但最多只会保留两个，其他会被设置为null\n        for (int i = 0; i < COUNT; i++) {\n            byte[] buff = new byte[1024 * 1024];\n            WeakReference<byte[]> sr = new WeakReference<>(buff);\n            buff = null;\n            list.add(sr);\n        }\n        System.out.println(\"list: \" + list.size());\n    }\n\n    private static void print() {\n        for(int i=0; i < list.size(); i++){\n            Object obj = list.get(i);\n            if(obj instanceof SoftReference) {\n                System.out.println(\"SoftReference: \" + i + \"= \" +  ((SoftReference)obj).get());\n            } else if(obj instanceof WeakReference) {\n                System.out.println(\"WeakReference: \" + i + \"= \" +  ((WeakReference)obj).get());\n            }\n            else {\n                System.out.println(i + \"= \" + obj);\n            }\n        }\n\n    }\n\n}\n\n//输出 可以发现SoftReference无论是否调用gc总是会有值，WeakReference使用后再调用gc就会设置为null\n```\n\n> 在使用软引用和弱引用的时候，可以显示地通过System.gc()来通知JVM进行垃圾回收，但是要注意的是，虽然发出了通知，JVM不一定会立刻执行，也就是说这句是无法确保此时JVM一定会进行垃圾回收的。\n\n## 虚引用\n\n虚引用是所有类型中最弱的一个。一个持有虚引用的对象和没有引用几乎是一样的，随时可能被垃圾回收器回收，当试图通过虚引用的get()方法取得强引用时，总是会失败。\n\n虚引用必须和引用队列一起使用，它的作用在于检测对象是否已经从内存中删除，跟踪垃圾回收过程。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在垃圾回收后，销毁这个对象，将这个虚引用加入引用队列。程序可以通过判断引用队列中是否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收。如果程序发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取必要的行动。\n\n类型 | 回收时间 | 使用场景\n---|---|---\n强引用 | 一直存活 | \t所有程序的场景，基本对象，自定义对象等。\n软引用SoftReference | 内存不足时会被回收 | \t一般用在对内存非常敏感的资源上，用作缓存的场景比较多，例如：网页缓存、图片缓存\n弱引用WeakReference | 只能存活到下一次GC前 | \t生命周期很短的对象，例如ThreadLocal中的Key。\n虚引用 | 随时会被回收， 创建了可能很快就会被回 | \t业界暂无使用场景， 可能被JVM团队内部用来跟踪JVM的垃圾回收活动\n\n\n# 引用队列（ReferenceQueue）\n\n官方对于引用队列类的注释是：\n\n> Reference queues, to which registered reference objects are appended by the garbage collector after the appropriate reachability changes are detected. 译为：引用队列是将垃圾收集器在监测到适当的可达性更改后将已注册的引用对象添加到该队列。\n\n对于软引用和弱引用和虚引用，我们希望**当一个对象被gc掉的时候通知用户线程，进行额外的处理时**，就需要使用引用队列了。ReferenceQueue即这样的一个对象，当一个obj被gc掉之后，其相应的包装类，即ref对象会被放入queue中。我们可以从queue中获取到相应的对象信息，同时进行额外的处理。比如反向操作，数据清理等:\n\n``` Java\nSoftReference ref = null;\nwhile ((ref = (EmployeeRef) q.poll()) != null) {\n// 清除ref\n}\n```\n\n实际上ReferenceQueue只是名义上的引用队列，它只保存了Reference链表的头(head)节点，并且提供了队列出队入队删除操作，而Reference实际上本身提供单向链表的功能，也就是说Reference通过成员属性next构建单向链表，而链表的操作是委托给ReferenceQueue完成。\n\n``` Java\npublic class SoftReferenceTest {\n\n\n    static class HeapObject {\n        byte[] bs = new byte[1024 * 1024];\n    }\n\n    public static void main(String[] args) {\n        ReferenceQueue<HeapObject> queue = new ReferenceQueue<>();\n        SoftReference<HeapObject> softReference = new SoftReference<>(new HeapObject(),queue);\n\n        List<HeapObject> list = new ArrayList<>();\n\n        while (true) {\n            if (softReference.get() != null) {\n                list.add(new HeapObject());\n                System.out.println(\"list.add\");\n            } else {\n                System.out.println(\"---------软引用已被回收---------\");\n                break;\n            }\n            System.gc();\n        }\n        Reference<? extends  HeapObject> pollRef = queue.poll();\n        while (pollRef != null) {\n            System.out.println(pollRef);\n            System.out.println(pollRef.get());\n            pollRef = queue.poll();\n        }\n    }\n}\n```\n\n设置VM options:-Xms5m -Xmx5m -XX:+PrintGC\n\n``` Java\nbyte[] data = new byte[1*1024*1024];\nReferenceQueue<Object> referenceQueue = new ReferenceQueue<>();\nSoftReference<byte[]> softReference = new SoftReference<>(data,referenceQueue);\ndata = null;\nSystem.out.println(\"before:\"+softReference.get());\n\ntry {\n    for (int i = 0; i < 10; i++) {\n        byte[] temp = new byte[3*1024*1024];\n        System.out.println(\"processing:\"+softReference.get());\n    }\n} catch (Throwable t) {\n    System.out.println(\"after:\"+softReference.get());\n    t.printStackTrace();\n}\nwhile(referenceQueue.poll()!=null){\n    System.out.println(\"self:\"+softReference);\n    softReference.clear();\n    softReference = null;\n    System.out.println(\"last:\"+softReference);\n}\n\n```\n\n> ReferenceQueue引用队列用来记录被回收的引用为用户线程做额外操作作铺垫\n\n# VisualVM使用\n\nVisualVM是集成JDK命令行工具和轻量级分析功能的可视化分析工具，设计用于开发和生产时间的使用。它提供了一个可视化界面，用于查看基于Java技术、运行于JVM上的应用程序(Java应用程序)的详细信息。\n\noracle版本的JDK 6〜8默认在bin目录下的jvisualvm.exe, 从Oracle JDK 9中开始已经不再内置visualvm(openjdk默认也是不包含的), 可以自己下载安装\n\n## 下载安装\n\n官网下载[最新版本](https://visualvm.github.io/releases.html)\n\n直接双击打开bin目录下的visualvm.exe\n\n> 如果出现cannot find java 1.8 or higher等问题的话, 则需要在etc目录下的visualvm.conf文件中加入jdk的目录，如：\n\n```\nvisualvm_jdkhome=\"C:\\Users\\jone.sun\\.jdks\\adopt-openjdk-1.8.0_275\"\n```\n\n### IDEA中使用\n\n打开IDEA的插件设置页面，搜索VisualVM Launcher，进行安装\n\n![VisualVM Launcher](VisualVM Launcher.png)\n\n完毕后即可通过IDEA启动VisualVM和自己的应用程序, 初次使用可能需要设置下路径:\n\n![VisualVM Launcher Setting](VisualVM Launcher Setting.png)\n\n之后就可以直接使用了![VisualVM Launcher Run](VisualVM Launcher Run.png)\n\n\n## 功能介绍\n\n### Sampler(抽样器)\n\n点击CPU，就可以看到各个类以及方法执行的时间，可以监控哪个类的方法执行时间较长，可以定位到具体的异常方法。\n\n点击内存，很直观的能找到哪个位置可能存在内存泄漏的情况。\n\n通过 Applications 窗口右击应用程序节点来启用\"Heap Dump on OOME(在出现 OOME 时生成堆 Dump)\"功能，当应用程序出现 OutOfMemory 例外时，VisualVM 将自动生成一个堆转储。\n\n> 除了监控本地的应用程序，同样可以远程监控局域网内的服务器","tags":["面试八股文","Java基础"],"categories":["Java","Java基础"]},{"title":"一款好用的Markdown编辑阅读器","url":"/2022/05/20/CmdMarkdown编辑器/","content":"# 欢迎使用 Cmd Markdown 编辑阅读器\n\n------\n\n我们理解您需要更便捷更高效的工具记录思想，整理笔记、知识，并将其中承载的价值传播给他人，**Cmd Markdown** 是我们给出的答案 —— 我们为记录思想和分享知识提供更专业的工具。 您可以使用 Cmd Markdown：\n\n> * 整理知识，学习笔记\n> * 发布日记，杂文，所见所想\n> * 撰写发布技术文稿（代码支持）\n> * 撰写发布学术论文（LaTeX 公式支持）\n\n![cmd-markdown-logo](https://www.zybuluo.com/static/img/logo.png)\n\n除了您现在看到的这个 Cmd Markdown 在线版本，您还可以前往以下网址下载：\n\n### [Windows/Mac/Linux 全平台客户端](https://www.zybuluo.com/cmd/)\n\n> 请保留此份 Cmd Markdown 的欢迎稿兼使用说明，如需撰写新稿件，点击顶部工具栏右侧的 <i class=\"icon-file\"></i> **新文稿** 或者使用快捷键 `Ctrl+Alt+N`。\n\n------\n\n## 什么是 Markdown\n\nMarkdown 是一种方便记忆、书写的纯文本标记语言，用户可以使用这些标记符号以最小的输入代价生成极富表现力的文档：譬如您正在阅读的这份文档。它使用简单的符号标记不同的标题，分割不同的段落，**粗体** 或者 *斜体* 某些文字，更棒的是，它还可以\n\n### 1. 制作一份待办事宜 [Todo 列表](https://www.zybuluo.com/mdeditor?url=https://www.zybuluo.com/static/editor/md-help.markdown#13-待办事宜-todo-列表)\n\n- [ ] 支持以 PDF 格式导出文稿\n- [ ] 改进 Cmd 渲染算法，使用局部渲染技术提高渲染效率\n- [x] 新增 Todo 列表功能\n- [x] 修复 LaTex 公式渲染问题\n- [x] 新增 LaTex 公式编号功能\n\n### 2. 书写一个质能守恒公式[^LaTeX]\n\n$$E=mc^2$$\n\n### 3. 高亮一段代码[^code]\n\n```python\n@requires_authorization\nclass SomeClass:\n    pass\n\nif __name__ == '__main__':\n    # A comment\n    print 'hello world'\n```\n\n### 4. 高效绘制 [流程图](https://www.zybuluo.com/mdeditor?url=https://www.zybuluo.com/static/editor/md-help.markdown#7-流程图)\n\n```flow\nst=>start: Start\nop=>operation: Your Operation\ncond=>condition: Yes or No?\ne=>end\n\nst->op->cond\ncond(yes)->e\ncond(no)->op\n```\n\n### 5. 高效绘制 [序列图](https://www.zybuluo.com/mdeditor?url=https://www.zybuluo.com/static/editor/md-help.markdown#8-序列图)\n\n```seq\nAlice->Bob: Hello Bob, how are you?\nNote right of Bob: Bob thinks\nBob-->Alice: I am good thanks!\n```\n\n### 6. 高效绘制 [甘特图](https://www.zybuluo.com/mdeditor?url=https://www.zybuluo.com/static/editor/md-help.markdown#9-甘特图)\n\n```gantt\n    title 项目开发流程\n    section 项目确定\n        需求分析       :a1, 2016-06-22, 3d\n        可行性报告     :after a1, 5d\n        概念验证       : 5d\n    section 项目实施\n        概要设计      :2016-07-05  , 5d\n        详细设计      :2016-07-08, 10d\n        编码          :2016-07-15, 10d\n        测试          :2016-07-22, 5d\n    section 发布验收\n        发布: 2d\n        验收: 3d\n```\n\n### 7. 绘制表格\n\n| 项目        | 价格   |  数量  |\n| --------   | -----:  | :----:  |\n| 计算机     | \\$1600 |   5     |\n| 手机        |   \\$12   |   12   |\n| 管线        |    \\$1    |  234  |\n\n### 8. 更详细语法说明\n\n想要查看更详细的语法说明，可以参考我们准备的 [Cmd Markdown 简明语法手册][1]，进阶用户可以参考 [Cmd Markdown 高阶语法手册][2] 了解更多高级功能。\n\n总而言之，不同于其它 *所见即所得* 的编辑器：你只需使用键盘专注于书写文本内容，就可以生成印刷级的排版格式，省却在键盘和工具栏之间来回切换，调整内容和格式的麻烦。**Markdown 在流畅的书写和印刷级的阅读体验之间找到了平衡。** 目前它已经成为世界上最大的技术分享网站 GitHub 和 技术问答网站 StackOverFlow 的御用书写格式。\n\n---\n\n## 什么是 Cmd Markdown\n\n您可以使用很多工具书写 Markdown，但是 Cmd Markdown 是这个星球上我们已知的、最好的 Markdown 工具——没有之一 ：）因为深信文字的力量，所以我们和你一样，对流畅书写，分享思想和知识，以及阅读体验有极致的追求，我们把对于这些诉求的回应整合在 Cmd Markdown，并且一次，两次，三次，乃至无数次地提升这个工具的体验，最终将它演化成一个 **编辑/发布/阅读** Markdown 的在线平台——您可以在任何地方，任何系统/设备上管理这里的文字。\n\n### 1. 实时同步预览\n\n我们将 Cmd Markdown 的主界面一分为二，左边为**编辑区**，右边为**预览区**，在编辑区的操作会实时地渲染到预览区方便查看最终的版面效果，并且如果你在其中一个区拖动滚动条，我们有一个巧妙的算法把另一个区的滚动条同步到等价的位置，超酷！\n\n### 2. 编辑工具栏\n\n也许您还是一个 Markdown 语法的新手，在您完全熟悉它之前，我们在 **编辑区** 的顶部放置了一个如下图所示的工具栏，您可以使用鼠标在工具栏上调整格式，不过我们仍旧鼓励你使用键盘标记格式，提高书写的流畅度。\n\n![tool-editor](https://www.zybuluo.com/static/img/toolbar-editor.png)\n\n### 3. 编辑模式\n\n完全心无旁骛的方式编辑文字：点击 **编辑工具栏** 最右侧的拉伸按钮或者按下 `Ctrl + M`，将 Cmd Markdown 切换到独立的编辑模式，这是一个极度简洁的写作环境，所有可能会引起分心的元素都已经被挪除，超清爽！\n\n### 4. 实时的云端文稿\n\n为了保障数据安全，Cmd Markdown 会将您每一次击键的内容保存至云端，同时在 **编辑工具栏** 的最右侧提示 `已保存` 的字样。无需担心浏览器崩溃，机器掉电或者地震，海啸——在编辑的过程中随时关闭浏览器或者机器，下一次回到 Cmd Markdown 的时候继续写作。\n\n### 5. 离线模式\n\n在网络环境不稳定的情况下记录文字一样很安全！在您写作的时候，如果电脑突然失去网络连接，Cmd Markdown 会智能切换至离线模式，将您后续键入的文字保存在本地，直到网络恢复再将他们传送至云端，即使在网络恢复前关闭浏览器或者电脑，一样没有问题，等到下次开启 Cmd Markdown 的时候，她会提醒您将离线保存的文字传送至云端。简而言之，我们尽最大的努力保障您文字的安全。\n\n### 6. 管理工具栏\n\n为了便于管理您的文稿，在 **预览区** 的顶部放置了如下所示的 **管理工具栏**：\n\n![tool-manager](https://www.zybuluo.com/static/img/toolbar-manager.jpg)\n\n通过管理工具栏可以：\n\n<i class=\"icon-share\"></i> 发布：将当前的文稿生成固定链接，在网络上发布，分享\n<i class=\"icon-file\"></i> 新建：开始撰写一篇新的文稿\n<i class=\"icon-trash\"></i> 删除：删除当前的文稿\n<i class=\"icon-cloud\"></i> 导出：将当前的文稿转化为 Markdown 文本或者 Html 格式，并导出到本地\n<i class=\"icon-reorder\"></i> 列表：所有新增和过往的文稿都可以在这里查看、操作\n<i class=\"icon-pencil\"></i> 模式：切换 普通/Vim/Emacs 编辑模式\n\n### 7. 阅读工具栏\n\n![tool-manager](https://www.zybuluo.com/static/img/toolbar-reader.jpg)\n\n通过 **预览区** 右上角的 **阅读工具栏**，可以查看当前文稿的目录并增强阅读体验。\n\n工具栏上的五个图标依次为：\n\n<i class=\"icon-list\"></i> 目录：快速导航当前文稿的目录结构以跳转到感兴趣的段落\n<i class=\"icon-chevron-sign-left\"></i> 视图：互换左边编辑区和右边预览区的位置\n<i class=\"icon-adjust\"></i> 主题：内置了黑白两种模式的主题，试试 **黑色主题**，超炫！\n<i class=\"icon-desktop\"></i> 阅读：心无旁骛的阅读模式提供超一流的阅读体验\n<i class=\"icon-fullscreen\"></i> 全屏：简洁，简洁，再简洁，一个完全沉浸式的写作和阅读环境\n\n### 8. 阅读模式\n\n在 **阅读工具栏** 点击 <i class=\"icon-desktop\"></i> 或者按下 `Ctrl+Alt+M` 随即进入独立的阅读模式界面，我们在版面渲染上的每一个细节：字体，字号，行间距，前背景色都倾注了大量的时间，努力提升阅读的体验和品质。\n\n### 9. 标签、分类和搜索\n\n在编辑区任意行首位置输入以下格式的文字可以标签当前文档：\n\n标签： 未分类\n\n标签以后的文稿在【文件列表】（Ctrl+Alt+F）里会按照标签分类，用户可以同时使用键盘或者鼠标浏览查看，或者在【文件列表】的搜索文本框内搜索标题关键字过滤文稿，如下图所示：\n\n![file-list](https://www.zybuluo.com/static/img/file-list.png)\n\n### 10. 文稿发布和分享\n\n在您使用 Cmd Markdown 记录，创作，整理，阅读文稿的同时，我们不仅希望它是一个有力的工具，更希望您的思想和知识通过这个平台，连同优质的阅读体验，将他们分享给有相同志趣的人，进而鼓励更多的人来到这里记录分享他们的思想和知识，尝试点击 <i class=\"icon-share\"></i> (Ctrl+Alt+P) 发布这份文档给好友吧！\n\n------\n\n再一次感谢您花费时间阅读这份欢迎稿，点击 <i class=\"icon-file\"></i> (Ctrl+Alt+N) 开始撰写新的文稿吧！祝您在这里记录、阅读、分享愉快！\n\n作者 [@ghosert][3]     \n2016 年 07月 07日\n\n[^LaTeX]: 支持 **LaTeX** 编辑显示支持，例如：$\\sum_{i=1}^n a_i=0$， 访问 [MathJax][4] 参考更多使用方法。\n\n[^code]: 代码高亮功能支持包括 Java, Python, JavaScript 在内的，**四十一**种主流编程语言。\n\n[1]: https://www.zybuluo.com/mdeditor?url=https://www.zybuluo.com/static/editor/md-help.markdown\n[2]: https://www.zybuluo.com/mdeditor?url=https://www.zybuluo.com/static/editor/md-help.markdown#cmd-markdown-高阶语法手册\n[3]: http://weibo.com/ghosert\n[4]: http://meta.math.stackexchange.com/questions/5020/mathjax-basic-tutorial-and-quick-reference\n\n","tags":["软件分享"],"categories":["杂七杂八","软件安利"]}]