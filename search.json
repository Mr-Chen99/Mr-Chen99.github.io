[{"title":"Git操作整理","url":"/2023/03/20/Git操作整理/","content":"\n## Github上Fork的项目如何获取源更新\n\n>  1、添加上游项目地址(URL为Fork的源项目地址)\n``` cmd\n    git remote add upstream URL\n```\n\n> 2、查看远程仓库信息(可以看到上游项目地址已经添加进来了)\n```cmd\n    git remote -v\n```\n![img](git-fork.png)\n\n> 3、获取上游项目更新(获取到的更新会被保存在本地的 upstream/master 分支)\n```cmd\n    git fetch upstream\n```\n> 4、合并到本地分支(如果不是master分支，要切换到 master 分支，然后合并 upstream/master 分支)\n```cmd\n    git merge upstream/master\n```\n>5、把更新后的代码push到git上\n```cmd\n    git push origin master\n```\n","tags":["项目"],"categories":["Git"]},{"title":"一、环境搭建","url":"/2023/03/11/某马XX交友项目-1-环境搭建/","content":"\n## 1、项目介绍\n\n探花交友是一个陌生人的在线交友平台，在该平台中可以搜索附近的人，查看好友动态，平台还会通过大数据计算进行智能推荐，通过智能推荐可以找到更加匹配的好友，这样才能增进用户对产品的喜爱度。探花平台还提供了在线即时通讯功能，可以实时的与好友进行沟通，让沟通随时随地的进行。\n\n### 1.1、功能列表\n\n| 功能       | 说明                                           | 备注                                           |\n| ---------- | ---------------------------------------------- | ---------------------------------------------- |\n| 注册、登录 | 用户无需单独注册，直接通过手机号登录即可       | 首次登录成功后需要完善个人信息                 |\n| 交友       | 主要功能有：测灵魂、桃花传音、搜附近、探花等   |                                                |\n| 圈子       | 类似微信朋友圈，用户可以发动态、查看好友动态等 |                                                |\n| 消息       | 通知类消息 + 即时通讯消息                      |                                                |\n| 小视频     | 类似抖音，用户可以发小视频，评论等             | 显示小视频列表需要进行推荐算法计算后进行展现。 |\n| 我的       | 我的动态、关注数、粉丝数、通用设置等           |                                                |\n\n### 1.2、项目背景\n\n探花交友项目定位于 **陌生人交友市场**。\n\n- 根据《2018社交领域投融资报告》中指出：虽然相比2017年，投融资事件减少29.5%，但是融资的总额却大幅增长，达到68%。\n- 这些迹象说明：社交领域的发展规模正在扩大，而很多没有特色的产品也会被淘汰。而随着那些尾部产品的倒下，对我们来说就是机会，及时抓住不同社交需求的机会。以社交为核心向不同的细分领域衍生正在逐渐走向成熟化。\n- 而我们按照娱乐形式和内容为主两个维度，将社交行业公司分类为：即时通信、内容社群、陌生人社交、泛娱乐社交以及兴趣社交几个领域。\n- 而在2018年社交的各个细分领域下，均有备受资本所关注的项目，根据烯牛数据2018年的报告中，也同样指出：内容社交及陌生人社交为资本重要关注领域，合计融资占比达73%。\n\n![img](clip_image002.jpg)\n\n根据市场现状以及融资事件来看：陌生人社交、内容社群、兴趣社交在2019年仍然保持强劲的动力，占到近70%的比例，它们仍然是资本市场主要关注领域。从增长率来看陌生人社交的增长速度远远大于其他几类，因此我们要从这个方向入手\n\n### 1.3、功能概述\n\n#### 1.3.1 用户登录\n\n业务说明：\n\n用户通过手机验证码进行登录，如果是第一次登录则需要完善个人信息，在上传图片时，需要对上传的图片做人像的校验，防止用户上传非人像的图片作为头像。流程完成后，则登录成功。\n\n![1563681330146](1563681330146.png)\n\n![1563681348382](1563681348382.png)\n\n![1563681365123](1563681365123.png)\n\n![1563681382592](1563681382592.png)\n\n![1563681397466](1563681397466.png)\n\n![1563681412881](1563681412881.png)\n\n#### 1.3.2、交友\n\n交友是探花项目的核心功能之一，用户可以查看好友，添加好友，搜索好友等操作。\n\n![1563698504256](1563698504256.png)\n\n##### 首页\n\n在首页中，主要功能有“今日佳人”、“推荐”、“最近访客”等\n\n- 今日佳人\n    - 按照“缘分值”进行匹配，将“缘分值”最高的用户展现出来\n- 推荐\n    - 按照“缘分值”进行推荐，由后台的推荐系统计算得出，展现出来\n- 最近访客\n    - 显示最近来看“我”的用户\n\n##### 探花\n\n![1563714212568](1563714212568.png)\n\n> 说明：左划喜欢，右划不喜欢，每天限量不超过100个，开通会员可增加限额。双方互相喜欢则配对成功。\n>\n> 实现：数据来源推荐系统计算后的结果。\n\n##### 搜附近\n\n![1563714826374](1563714826374.png)\n\n根据用户当前所在的位置进行查询，并且在10km的范围内进行查询，可以通过筛选按钮进行条件筛选。\n\n##### 桃花传音\n\n功能类似QQ中的漂流瓶，用户可以发送和接收语音消息，陌生人就会接收到消息。\n\n![1563718868686](1563718868686.png)\n\n##### 测灵魂\n\n1. 测试题用于对用户进行分类，每次提交答案后更新用户属性\n2. 测试题在后台进行维护\n3. 测试题测试完后产生结果页可以进行分享\n\n4. 测试题为顺序回答，回答完初级题解锁下一级问题\n\n5. 点击锁定问题 显示提示 请先回答上一级问题\n\n![1563719052277](1563719052277.png)\n\n![1563719092059](1563719092059.png)\n\n![1563719100855](1563719100855.png)\n\n#### 1.3.3、圈子\n\n1、推荐频道为根据问卷及喜好推荐相似用户动态\n\n2、显示内容为用户头像、用户昵称、用户性别、用户年龄、用户标签和用户发布动态\n\n3、图片最多不超过6张或发布一个小视频\n\n4、动态下方显示发布时间距离当时时间，例如10分钟前、3小时前、2天前，显示时间进行取整\n\n5、动态下方显示距离为发布动态地与本地距离\n\n6、显示用户浏览量\n\n7、显示点赞数、评论数 转发数\n\n![1563719380223](1563719380223.png)\n\n![1563719403171](1563719403171.png)\n\n#### 1.3.4、消息\n\n消息包含通知类的消息和好友消息。\n\n![1563719621939](1563719621939.png)\n\n#### 1.3.5、小视频\n\n用户可以上传小视频，也可以查看小视频列表，并且可以进行点赞操作。\n\n![1563719761162](1563719761162.png)\n\n#### 1.3.6、我的\n\n显示关注数、喜欢数、粉丝数、我的动态等信息。\n\n![1563719894481](1563719894481.png)\n\n![1563719949700](1563719949700.png)\n\n\n\n。\n\n### 1.4、技术方案\n\n前端：\n\n- flutter + android + 环信SDK + redux + shared_preferences + connectivity + iconfont + webview + sqflite\n\n后端：\n\n- Spring Boot + SpringMVC + Mybatis + MybatisPlus + Dubbo\n- Elasticsearch geo 实现地理位置查询\n- MongoDB 实现海量数据的存储\n- Redis 数据的缓存\n- Spark + MLlib 实现智能推荐\n- 第三方服务 环信即时通讯\n- 第三方服务 阿里云 OSS 、 短信服务\n- 第三方服务 虹软开放平台 / 阿里云\n\n![1563457093887](1563457093887.png)\n\n### 1.5、技术解决方案\n\n- 使用Elasticsearch geo实现附近的人的解决方案\n- 使用Spark + Mllib实现智能推荐的解决方案\n- 使用MongoDB进行海量数据的存储的解决方案\n- 使用采用分布式文件系统存储小视频数据的解决方案\n- 使用百度人脸识别的解决方案\n- 使用阿里云进行短信验证码发送的解决方案\n\n## 2、前后端分离\n\n### 2.1、前后端分离的概述\n\n项目基于前后端分离的架构进行开发，前后端分离架构总体上包括前端和服务端，通常是多人协作开发\n\n* 前后端分离开发基于**HTTP+JSON**交互\n\n* 通过接口文档（API文档）定义规范\n\n* 前后端按照文档定义请求及响应数据\n\n![image-20210714095914770](image-20210714095914770.png)\n\n### 2.2、YAPI介绍\n\n> YAPI已经在linux虚拟机中准备好了\n>\n> 请求地址：http://192.168.136.160:3000/\n>\n> 用户名/密码：tanhua@itcast.cn/123456\n\n对于接口的定义我们采用YApi进行管理，YApi是一个开源的接口定义、管理、提供mock数据的管理平台。\n\n![image-20201017100705286](image-20201017100705286-1626228296625.png)\n\n接口定义：\n\n![image-20201017100848313](image-20201017100848313-1626228296625.png)\n\nmock数据，YApi提供了mock功能，就是模拟服务端返回测试数据：\n\n![image-20201017101228582](image-20201017101228582-1626228296625.png)\n\n![image-20201017101252482](image-20201017101252482-1626228296625.png)\n\n还可以运行http请求（需要在Chrome中安装支持跨域扩展 https://juejin.im/post/6844904057707085832）：\n\n![image-20201017103028622](image-20201017103028622-1626228296626.png)\n\n![image-20201017103045864](image-20201017103045864-1626228296626.png)\n\n## 3、开发工具\n\n探花交友项目的开发统一使用提供的Centos7环境，该环境中部署安装了项目所需要的各种服务，如：RabbitMQ,MongoDB、Redis等。\n\n- 虚拟机的root用户密码为：<font color=red>root123</font>\n- 默认参数：CPU：2核，内存：4G，硬盘：60G\n- IP地址建议设置为192.168.136.160，否则有些服务将不可用，比如：Redis、RocketMQ等。\n\n### 3.1、虚拟机配置\n\n由于课程中使用了较多的软件，且之间会有联系，推荐同学IP地址设置为192.168.136.160\n\n![image-20210714100818029](image-20210714100818029.png)\n\n仅仅需要修改虚拟机中的子网IP即可。\n\n### 3.2、Android模拟器\n\n客户端由前端团队进行开发，前端提供apk进行对接，所以，需要我们安装安卓的模拟器进行测试。\n\n目前对开发者有很多专业的模拟器如genymotion，但是这些模拟器功能强大，空间占用率高并不适用于教学，甚至在某些环境下不能正常的启动。所以可以选择国内的安卓模拟器产品，比如：网易、夜神等，在这里我们推荐使用网易模拟器，其兼容性好、功能完善而且还简洁，但是它不支持虚拟机中安装。\n\n下载：https://mumu.163.com/\n\n![image-20201016214917500](image-20201016214917500-1626229234043.png)\n\n### 3.3、调试工具PostMan\n\nPostman是一款功能强大的网页调试与发送网页HTTP请求的Chrome插件。postman被500万开发者和超100,000家公司用于每月访问1.3亿个API。\n\n官方网址：https://www.postman.com/\n\n解压资料文件夹中的软件，安装即可\n\n![image-20210714102512760](image-20210714102512760.png)\n\n## 4、环境搭建\n\n### 4.1、MYSQL数据库\n\n数据库设计规范：详见资料文件夹下[《](../资料/黑马头条-数据库规范设计说明书.md)[探花交友](../资料/黑马头条-数据库规范设计说明书.md)[-](../资料/黑马头条-数据库规范设计说明书.md)[mysq](../资料/黑马头条-数据库规范设计说明书.md)[表](../资料/黑马头条-数据库规范设计说明书.md)[.md》](../资料/黑马头条-数据库规范设计说明书.md)文件\n\n| 数据库表        | 说明       |\n| --------------- | ---------- |\n| tb_user         | 用户表     |\n| tb_user_info    | 用户详情表 |\n| tb_settings     | 用户设置表 |\n| tb_question     | 好友问题表 |\n| tb_black_list   | 黑名单     |\n| tb_announcement | 公告表     |\n\n将资料中数据库表导入到MYSQL中\n\n#### 4.1.1、导入数据库\n\n（1） 打开Navicat ，点击右键选择新建数据库，**名字跟我们要导入的数据库的名字一样**，字符集一般选utf-8\n\n![image-20210714114346530](image-20210714114346530.png)\n\n（2） 在新建的数据库上右击，选择“运行SQL文件”，在提示框中选择文件所在的路径，编码保持一致选择utf-8\n\n![image-20210714114414990](image-20210714114414990.png)\n\n（3） 提示Successfully 导入成功后，可能在左侧看不到导入的数据库，关闭Navicat，重新打开即可看到\n\n### 4.2、基础服务组件\n\n探花交友学习中，除MySQL数据库部署到本地电脑中。其他涉及到的所有组件都已经以docker形式安装到虚拟机中。我们只需要进入虚拟机，使用简单的命令即可。为了方便学习与减少基础服务占用的学习时间，全部使用docker-compose的方式集中式部署。这些文件在linux虚拟机中的/root/docker-file文件夹下\n\n![image-20210714102740424](image-20210714102740424.png)\n\n每个文件夹中都包含一个docker-compose.yml配置文件，一键启动并部署应用。\n\n```shell\n#进入组件目录\ncd /root/docker-file/base/\n#执行docker-compose命令\ndocker-compose up -d \n```\n\n**base**\n\n* 其中包含redis，nacos，yapi，mongo\n\n**fastdfs**\n\n* 包含fastdfs操作需要的组件\n\n**rmq**\n\n* 包含RabbitMQ需要所有组件\n\n**recommend**\n\n* 包含推荐系统需要所有组件\n\n### 4.3、IDEA配置\n\n项目依赖环境（需提前安装好）\n\n* JDK1.8\n\n* Intellij Idea\n\n* maven-3.x以上\n\n* Git\n\n* UTF-8编码格式\n\n#### 设置项目编码格式\n\n![image-20210714102921973](image-20210714102921973.png)\n\n#### 设置Maven仓库\n\n设置本地仓库，建议使用资料中提供好的仓库\n\n![image-20210714102941712](image-20210714102941712.png)\n\n### 4.4、Maven模块分析\n\n整体项目使用Maven架构搭建，采用聚合工程形式管理模块，为了便于调用，dubbo需要拆分为接口模块和服务模块\n\n![image-20210714103025777](image-20210714103025777.png)\n\n**工程主体结构**\n\n| **父工程**   | **工程名称**           | **说明**                                       |\n| ------------ | ---------------------- | ---------------------------------------------- |\n| tanhua       | tanhua-autoconfig      | 自动装配的工具类                               |\n| tanhua       | tanhua-domain          | 实体类模块                                     |\n| tanhua       | tanhua-dubbo           | Dubbo子模块（可以理解为文件夹，管理dubbo模块） |\n| tanhua       | tanhua-app             | 与手机端交互的入口模块                         |\n| tanhua-dubbo | tanhua-dubbo-interface | Dubbo接口模块                                  |\n| tanhua-dubbo | tanhua-dubbo-db        | Dubbo服务模块（数据库部分）                    |\n| tanhua-dubbo | tanhua-dubbo-mongo     | Dubbo服务模块（MongoDB部分）                   |\n\n**模块依赖分析**\n\n![image-20210714103104326](image-20210714103104326.png)\n\n### 4.5、模块依赖\n\n#### tanhua\n\n```xml\n<properties>\n    <maven.compiler.source>8</maven.compiler.source>\n    <maven.compiler.target>8</maven.compiler.target>\n    <mysql.version>5.1.47</mysql.version>\n    <jackson.version>2.11.0</jackson.version>\n    <druid.version>1.0.9</druid.version>\n    <servlet-api.version>2.5</servlet-api.version>\n    <jsp-api.version>2.0</jsp-api.version>\n    <joda-time.version>2.5</joda-time.version>\n    <commons-lang3.version>3.3.2</commons-lang3.version>\n    <commons-io.version>1.3.2</commons-io.version>\n    <mybatis.version>3.5.6</mybatis.version>\n    <mybatis.mybatis-plus>3.4.1</mybatis.mybatis-plus>\n    <lombok.version>1.18.8</lombok.version>\n    <mongo.version>4.0.5</mongo.version>\n    <spring-cloud.version>Hoxton.SR10</spring-cloud.version>\n    <spring-cloud-alibaba.version>2.2.5.RELEASE</spring-cloud-alibaba.version>\n</properties>\n\n<!--通用依赖-->\n<dependencies>\n    <dependency>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-test</artifactId>\n        <scope>test</scope>\n    </dependency>\n    <dependency>\n        <groupId>junit</groupId>\n        <artifactId>junit</artifactId>\n        <version>4.12</version>\n        <scope>test</scope>\n    </dependency>\n    <dependency>\n        <groupId>org.projectlombok</groupId>\n        <artifactId>lombok</artifactId>\n    </dependency>\n    <dependency>\n        <groupId>cn.hutool</groupId>\n        <artifactId>hutool-all</artifactId>\n        <version>5.4.3</version>\n    </dependency>\n    <dependency>\n        <groupId>com.alibaba</groupId>\n        <artifactId>fastjson</artifactId>\n        <version>1.2.8</version>\n    </dependency>\n</dependencies>\n\n<dependencyManagement>\n    <dependencies>\n        <dependency>\n            <groupId>io.netty</groupId>\n            <artifactId>netty-bom</artifactId>\n            <version>4.1.59.Final</version>\n            <type>pom</type>\n            <scope>import</scope>\n        </dependency>\n\n        <dependency>\n            <groupId>io.projectreactor</groupId>\n            <artifactId>reactor-bom</artifactId>\n            <version>2020.0.4</version>\n            <type>pom</type>\n            <scope>import</scope>\n        </dependency>\n\n        <dependency>\n            <groupId>io.projectreactor.netty</groupId>\n            <artifactId>reactor-netty</artifactId>\n            <version>0.9.8.RELEASE</version>\n        </dependency>\n\n        <dependency>\n            <groupId>org.springframework.cloud</groupId>\n            <artifactId>spring-cloud-dependencies</artifactId>\n            <version>${spring-cloud.version}</version>\n            <type>pom</type>\n            <scope>import</scope>\n        </dependency>\n\n        <dependency>\n            <groupId>com.alibaba.cloud</groupId>\n            <artifactId>spring-cloud-alibaba-dependencies</artifactId>\n            <version>${spring-cloud-alibaba.version}</version>\n            <type>pom</type>\n            <scope>import</scope>\n        </dependency>\n\n        <dependency>\n            <groupId>joda-time</groupId>\n            <artifactId>joda-time</artifactId>\n            <version>${joda-time.version}</version>\n        </dependency>\n\n        <!-- mybatis-plus插件依赖 -->\n        <dependency>\n            <groupId>com.baomidou</groupId>\n            <artifactId>mybatis-plus</artifactId>\n            <version>${mybatis.mybatis-plus}</version>\n        </dependency>\n\n        <!-- MySql -->\n        <dependency>\n            <groupId>mysql</groupId>\n            <artifactId>mysql-connector-java</artifactId>\n            <version>${mysql.version}</version>\n        </dependency>\n\n        <dependency>\n            <groupId>org.mongodb</groupId>\n            <artifactId>mongodb-driver-sync</artifactId>\n            <version>${mongodb.version}</version>\n        </dependency>\n\n        <dependency>\n            <groupId>org.projectlombok</groupId>\n            <artifactId>lombok</artifactId>\n            <optional>true</optional>\n            <version>${lombok.version}</version>\n        </dependency>\n\n        <dependency>\n            <groupId>org.apache.commons</groupId>\n            <artifactId>commons-lang3</artifactId>\n            <version>${commons-lang3.version}</version>\n        </dependency>\n\n        <dependency>\n            <groupId>org.apache.commons</groupId>\n            <artifactId>commons-lang3</artifactId>\n            <version>3.7</version>\n        </dependency>\n        <!-- Jackson Json处理工具包 -->\n        <dependency>\n            <groupId>com.fasterxml.jackson.core</groupId>\n            <artifactId>jackson-databind</artifactId>\n            <version>${jackson.version}</version>\n        </dependency>\n        <dependency>\n            <groupId>com.alibaba</groupId>\n            <artifactId>druid</artifactId>\n            <version>${druid.version}</version>\n        </dependency>\n        <dependency>\n            <groupId>commons-codec</groupId>\n            <artifactId>commons-codec</artifactId>\n            <version>1.11</version>\n        </dependency>\n    </dependencies>\n</dependencyManagement>\n\n<build>\n    <plugins>\n        <!-- java编译插件 -->\n        <plugin>\n            <groupId>org.apache.maven.plugins</groupId>\n            <artifactId>maven-compiler-plugin</artifactId>\n            <version>3.2</version>\n            <configuration>\n                <source>1.8</source>\n                <target>1.8</target>\n                <encoding>UTF-8</encoding>\n            </configuration>\n        </plugin>\n    </plugins>\n</build>\n```\n\n#### tanhua-app-server\n\n```xml\n<dependencies>\n\n    <dependency>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-web</artifactId>\n    </dependency>\n\n    <!--SpringDataRedis依赖-->\n    <dependency>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-data-redis</artifactId>\n    </dependency>\n\n    <!--lombok依赖-->\n    <dependency>\n        <groupId>org.projectlombok</groupId>\n        <artifactId>lombok</artifactId>\n    </dependency>\n\n    <!--工具包-->\n    <dependency>\n        <groupId>org.apache.commons</groupId>\n        <artifactId>commons-lang3</artifactId>\n    </dependency>\n    <dependency>\n        <groupId>com.fasterxml.jackson.core</groupId>\n        <artifactId>jackson-databind</artifactId>\n    </dependency>\n    <dependency>\n        <groupId>commons-codec</groupId>\n        <artifactId>commons-codec</artifactId>\n    </dependency>\n    <dependency>\n        <groupId>joda-time</groupId>\n        <artifactId>joda-time</artifactId>\n    </dependency>\n\n    <!--jwt依赖-->\n    <dependency>\n        <groupId>io.jsonwebtoken</groupId>\n        <artifactId>jjwt</artifactId>\n        <version>0.9.1</version>\n    </dependency>\n\n    <!--fastdfs文件存储-->\n    <dependency>\n        <groupId>com.github.tobato</groupId>\n        <artifactId>fastdfs-client</artifactId>\n        <version>1.26.7</version>\n        <exclusions>\n            <exclusion>\n                <groupId>ch.qos.logback</groupId>\n                <artifactId>logback-classic</artifactId>\n            </exclusion>\n        </exclusions>\n    </dependency>\n\n\n    <!-- Dubbo Spring Cloud Starter-->\n    <dependency>\n        <groupId>com.alibaba.cloud</groupId>\n        <artifactId>spring-cloud-starter-dubbo</artifactId>\n    </dependency>\n\n    <!-- Spring Cloud Nacos Service Discovery-->\n    <dependency>\n        <groupId>com.alibaba.cloud</groupId>\n        <artifactId>spring-cloud-starter-alibaba-nacos-discovery</artifactId>\n    </dependency>\n\n    <!-- nacos配置中心依赖支持\n    <dependency>\n        <groupId>com.alibaba.cloud</groupId>\n        <artifactId>spring-cloud-starter-alibaba-nacos-config</artifactId>\n    </dependency>\n\t-->\n    <!--RabbitMQ\n    <dependency>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-amqp</artifactId>\n    </dependency>\n\t-->\n    <dependency>\n        <groupId>com.itheima</groupId>\n        <artifactId>tanhua-dubbo-interface</artifactId>\n        <version>1.0-SNAPSHOT</version>\n    </dependency>\n    <dependency>\n        <groupId>com.itheima</groupId>\n        <artifactId>tanhua-commons</artifactId>\n        <version>1.0-SNAPSHOT</version>\n    </dependency>\n    <dependency>\n        <groupId>com.itheima</groupId>\n        <artifactId>tanhua-autoconfig</artifactId>\n        <version>1.0-SNAPSHOT</version>\n    </dependency>\n</dependencies>\n\n<build>\n    <finalName>tanhua-app-server</finalName>\n    <plugins>\n        <plugin>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-maven-plugin</artifactId>\n            <version>2.3.9.RELEASE</version>\n        </plugin>\n    </plugins>\n</build>\n```\n\n#### tanhua-autoconfig\n\n```xml\n<dependencies>\n    <!--阿里云核心API-->\n    <dependency>\n        <groupId>com.aliyun</groupId>\n        <artifactId>aliyun-java-sdk-core</artifactId>\n        <version>4.5.3</version>\n    </dependency>\n    <dependency>\n        <groupId>com.aliyun</groupId>\n        <artifactId>dysmsapi20170525</artifactId>\n        <version>2.0.1</version>\n    </dependency>\n    <!--阿里云oss存储API-->\n    <dependency>\n        <groupId>com.aliyun.oss</groupId>\n        <artifactId>aliyun-sdk-oss</artifactId>\n        <version>3.10.2</version>\n    </dependency>\n    <!--阿里云人识别-->\n    <dependency>\n        <groupId>com.aliyun</groupId>\n        <artifactId>facebody20191230</artifactId>\n        <version>1.0.10</version>\n    </dependency>\n    <!--百度人脸识别API-->\n    <dependency>\n        <groupId>com.baidu.aip</groupId>\n        <artifactId>java-sdk</artifactId>\n        <version>4.8.0</version>\n    </dependency>\n    <!--springboot基础起步依赖-->\n    <dependency>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-web</artifactId>\n    </dependency>\n    <dependency>\n        <groupId>com.easemob.im</groupId>\n        <artifactId>im-sdk-core</artifactId>\n        <version>0.2.5</version>\n    </dependency>\n    <dependency>\n        <groupId>com.aliyun</groupId>\n        <artifactId>aliyun-java-sdk-green</artifactId>\n        <version>3.6.1</version>\n    </dependency>\n</dependencies>\n```\n\n#### tanhua-commons\n\n```xml\n<dependencies>\n    <!--工具包-->\n    <dependency>\n        <groupId>org.apache.commons</groupId>\n        <artifactId>commons-lang3</artifactId>\n    </dependency>\n    <dependency>\n        <groupId>commons-codec</groupId>\n        <artifactId>commons-codec</artifactId>\n    </dependency>\n    <dependency>\n        <groupId>joda-time</groupId>\n        <artifactId>joda-time</artifactId>\n    </dependency>\n    <!--jwt依赖-->\n    <dependency>\n        <groupId>io.jsonwebtoken</groupId>\n        <artifactId>jjwt</artifactId>\n        <version>0.9.1</version>\n    </dependency>\n</dependencies>\n```\n\n#### tanhua-dubbo-db\n\n```xml\n<dependencies>\n\n    <dependency>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-web</artifactId>\n    </dependency>\n\n    <dependency>\n        <groupId>com.baomidou</groupId>\n        <artifactId>mybatis-plus</artifactId>\n    </dependency>\n\n    <dependency>\n        <groupId>com.baomidou</groupId>\n        <artifactId>mybatis-plus-boot-starter</artifactId>\n        <version>${mybatis.mybatis-plus}</version>\n    </dependency>\n\n    <dependency>\n        <groupId>mysql</groupId>\n        <artifactId>mysql-connector-java</artifactId>\n    </dependency>\n\n    <dependency>\n        <groupId>com.alibaba</groupId>\n        <artifactId>druid</artifactId>\n    </dependency>\n\n    <dependency>\n        <groupId>org.projectlombok</groupId>\n        <artifactId>lombok</artifactId>\n    </dependency>\n\n    <dependency>\n        <groupId>org.apache.commons</groupId>\n        <artifactId>commons-lang3</artifactId>\n    </dependency>\n\n    <dependency>\n        <groupId>com.fasterxml.jackson.core</groupId>\n        <artifactId>jackson-databind</artifactId>\n    </dependency>\n\n    <dependency>\n        <groupId>commons-codec</groupId>\n        <artifactId>commons-codec</artifactId>\n    </dependency>\n\n    <dependency>\n        <groupId>joda-time</groupId>\n        <artifactId>joda-time</artifactId>\n    </dependency>\n\n    <!-- Dubbo Spring Cloud Starter -->\n    <dependency>\n        <groupId>com.alibaba.cloud</groupId>\n        <artifactId>spring-cloud-starter-dubbo</artifactId>\n    </dependency>\n\n    <!-- Spring Cloud Nacos Service Discovery -->\n    <dependency>\n        <groupId>com.alibaba.cloud</groupId>\n        <artifactId>spring-cloud-starter-alibaba-nacos-discovery</artifactId>\n    </dependency>\n\n    <!-- nacos配置中心依赖支持\n    <dependency>\n        <groupId>com.alibaba.cloud</groupId>\n        <artifactId>spring-cloud-starter-alibaba-nacos-config</artifactId>\n    </dependency>\n\t-->\n    <dependency>\n        <groupId>com.itheima</groupId>\n        <artifactId>tanhua-dubbo-interface</artifactId>\n        <version>1.0-SNAPSHOT</version>\n    </dependency>\n</dependencies>\n\n<build>\n    <finalName>tanhua-dubbo-db</finalName>\n    <plugins>\n        <plugin>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-maven-plugin</artifactId>\n            <version>2.3.9.RELEASE</version>\n        </plugin>\n    </plugins>\n</build>\n```\n\n#### tanhua-dubbo-interface\n\n```xml\n<dependencies>\n    <dependency>\n        <groupId>com.itheima</groupId>\n        <artifactId>tanhua-model</artifactId>\n        <version>1.0-SNAPSHOT</version>\n    </dependency>\n</dependencies>\n```\n\n#### tanhua-dubbo-mongo\n\n```xml\n<dependencies>\n\n    <dependency>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-web</artifactId>\n    </dependency>\n\n    <dependency>\n        <groupId>org.projectlombok</groupId>\n        <artifactId>lombok</artifactId>\n    </dependency>\n\n    <dependency>\n        <groupId>org.apache.commons</groupId>\n        <artifactId>commons-lang3</artifactId>\n    </dependency>\n\n    <dependency>\n        <groupId>com.fasterxml.jackson.core</groupId>\n        <artifactId>jackson-databind</artifactId>\n    </dependency>\n\n    <dependency>\n        <groupId>commons-codec</groupId>\n        <artifactId>commons-codec</artifactId>\n    </dependency>\n\n    <dependency>\n        <groupId>joda-time</groupId>\n        <artifactId>joda-time</artifactId>\n    </dependency>\n\n    <!-- Dubbo Spring Cloud Starter -->\n    <dependency>\n        <groupId>com.alibaba.cloud</groupId>\n        <artifactId>spring-cloud-starter-dubbo</artifactId>\n    </dependency>\n\n    <!-- Spring Cloud Nacos Service Discovery -->\n    <dependency>\n        <groupId>com.alibaba.cloud</groupId>\n        <artifactId>spring-cloud-starter-alibaba-nacos-discovery</artifactId>\n    </dependency>\n\n    <!-- nacos配置中心依赖支持\n    <dependency>\n        <groupId>com.alibaba.cloud</groupId>\n        <artifactId>spring-cloud-starter-alibaba-nacos-config</artifactId>\n    </dependency>\n\t-->\n    <dependency>\n        <groupId>com.itheima</groupId>\n        <artifactId>tanhua-commons</artifactId>\n        <version>1.0-SNAPSHOT</version>\n    </dependency>\n\n    <dependency>\n        <groupId>com.itheima</groupId>\n        <artifactId>tanhua-dubbo-interface</artifactId>\n        <version>1.0-SNAPSHOT</version>\n    </dependency>\n</dependencies>\n\n<build>\n    <finalName>tanhua-dubbo-db</finalName>\n    <plugins>\n        <plugin>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-maven-plugin</artifactId>\n            <version>2.3.9.RELEASE</version>\n        </plugin>\n    </plugins>\n</build>\n```\n\n#### tanhua-model\n\n```xml\n<dependencies>\n    <!--SpringDataMongo起步依赖\n    <dependency>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-data-mongodb</artifactId>\n    </dependency>\n    <dependency>\n        <groupId>org.mongodb</groupId>\n        <artifactId>mongodb-driver-sync</artifactId>\n        <version>${mongodb.version}</version>\n    </dependency>\n\t-->\n    <!--MybatisPlus起步依赖-->\n    <dependency>\n        <groupId>com.baomidou</groupId>\n        <artifactId>mybatis-plus</artifactId>\n    </dependency>\n</dependencies>\n```\n\n### 4.6、搭建环境\n\ntanhua-app-server端添加引导类和配置文件application.yml\n\n```java\n//启动类\n@SpringBootApplication\npublic class AppServerApplication {\n\n    public static void main(String[] args) {\n        SpringApplication.run(AppServerApplication.class,args);\n    }\n}\n```\n\n### 4.7、Lombok\n\nlombok 提供了简单的注解的形式来帮助我们简化消除一些必须有但显得很臃肿的 java 代码，尤其是针对pojo。\n\n官网：https://projectlombok.org/\n\n#### 配置安装\n\n导入依赖：\n\n~~~xml\n<!--简化代码的工具包-->\n<dependency>\n    <groupId>org.projectlombok</groupId>\n    <artifactId>lombok</artifactId>\n    <optional>true</optional>\n</dependency>\n~~~\n\n安装IDEA插件： ![1542036205393](1542036205393.png)\n\n> 如果不安装插件，程序可以正常执行，但是看不到生成的一些代码，如：get、set方法。\n\n#### 常用注解\n\n- @Data：注解在类上；提供类所有属性的 getting 和 setting 方法，此外还提供了equals、canEqual、hashCode、toString 方法\n- @Setter：注解在属性上；为属性提供 setting 方法\n- @Getter：注解在属性上；为属性提供 getting 方法\n- @Slf4j：注解在类上；为类提供一个 属性名为log 的 slf4j日志对象\n- @NoArgsConstructor：注解在类上；为类提供一个无参的构造方法\n- @AllArgsConstructor：注解在类上；为类提供一个全参的构造方法\n- @Builder：使用Builder模式构建对象\n\n> 测试一：使用@Data注解\n\n![image-20201116113610810](image-20201116113610810.png)\n\n是不是很神奇？！\n\n> 测试二：使用@Slf4j注解\n\n![image-20201116113645107](image-20201116113645107.png)\n\n测试：\n\n![image-20201116113812602](image-20201116113812602.png)\n\n> 测试三：@AllArgsConstructor、@NoArgsConstructor注解的使用\n\n![image-20201116114013519](image-20201116114013519.png)\n\n> 测试四：@Builder\n\n![image-20201116114233416](image-20201116114233416.png)\n\n测试结果：\n\n![image-20201116114254202](image-20201116114254202.png)\n\n## 5、注册登录需求分析\n\n### 5.1、业务说明\n\n用户通过手机验证码进行登录，如果是第一次登录则需要完善个人信息，在上传图片时，需要对上传的图片做人像的校验，防止用户上传非人像的图片作为头像。流程完成后，则登录成功。\n\n* 已注册用户：\n    * 输入手机号发送验证码\n    * 输入验证码，进行比对完成登录\n* 未注册用户：\n    * 输入手机号发送验证码\n    * 输入验证码，进行比对，自动注册（保存用户）\n    * 完善用户信息\n\n### 5.2、需求分析\n\n服务端接受客户端请求\n\nJava代码调用第三方服务实现短信返送（发送短信需要运营资质，只能借助第三方实现）\n\n![image-20210714114654518](image-20210714114654518.png)\n\n### 5.3、数据库表\n\n数据库使用的mysql：\n\n~~~sql\nCREATE TABLE `tb_user` (\n  `id` bigint(20) NOT NULL AUTO_INCREMENT,\n  `mobile` varchar(11) DEFAULT NULL COMMENT '手机号',\n  `password` varchar(32) DEFAULT NULL COMMENT '密码，需要加密',\n  `created` datetime DEFAULT NULL,\n  `updated` datetime DEFAULT NULL,\n  PRIMARY KEY (`id`),\n  KEY `mobile` (`mobile`) USING BTREE\n) ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8 COMMENT='用户表';\n\nCREATE TABLE `tb_user_info` (\n  `id` bigint(20) NOT NULL AUTO_INCREMENT,\n  `user_id` bigint(20) NOT NULL COMMENT '用户id',\n  `nick_name` varchar(50) DEFAULT NULL COMMENT '昵称',\n  `logo` varchar(100) DEFAULT NULL COMMENT '用户头像',\n  `tags` varchar(50) DEFAULT NULL COMMENT '用户标签：多个用逗号分隔',\n  `sex` int(1) DEFAULT '3' COMMENT '性别，1-男，2-女，3-未知',\n  `age` int(11) DEFAULT NULL COMMENT '用户年龄',\n  `edu` varchar(20) DEFAULT NULL COMMENT '学历',\n  `city` varchar(20) DEFAULT NULL COMMENT '居住城市',\n  `birthday` varchar(20) DEFAULT NULL COMMENT '生日',\n  `cover_pic` varchar(50) DEFAULT NULL COMMENT '封面图片',\n  `industry` varchar(20) DEFAULT NULL COMMENT '行业',\n  `income` varchar(20) DEFAULT NULL COMMENT '收入',\n  `marriage` varchar(20) DEFAULT NULL COMMENT '婚姻状态',\n  `created` datetime DEFAULT NULL,\n  `updated` datetime DEFAULT NULL,\n  PRIMARY KEY (`id`),\n  KEY `user_id` (`user_id`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT='用户信息表';\n\n~~~\n\n### 5.4、实体类\n\n**User**\n\n```java\n@Data\n@AllArgsConstructor  //满参构造方法\n@NoArgsConstructor   //无参构造方法\npublic class User extends BasePojo {\n\n    private Long id;\n    private String mobile;\n    private String password;\n\n    //环信用户信息\n    private String hxUser;\n    private String hxPassword;\n}\n```\n\n## 6、短信验证码\n\n### 6.1、阿里云短信服务\n\n![image-20210714114820624](image-20210714114820624.png)\n\n官方网站：https://www.aliyun.com/product/sms?spm=5176.19720258.J_8058803260.611.48192c4abPvXEp\n\n#### 6.1.1、申请签名与模板\n\n使用阿里云短信服务非常简单，仅需要简单的申请和认证即可\n\nhttps://dysms.console.aliyun.com/dysms.htm?spm=5176.12818093.0.ddysms.2a4316d0ql6PyD\n\n![image-20201016193819097](image-20201016193819097.png)\n\n> 说明：申请签名时，个人用户只能申请一个并且签名的名称必须为“ABC商城”，否则审核不通过。\n\n申请模板：\n\n![image-20201016193927924](image-20201016193927924.png)\n\n> 审核时间需要1~2小时，请耐心等待~\n\n#### 6.1.2、示例代码\n\n文档：https://help.aliyun.com/document_detail/101414.html?spm=a2c4g.11186623.6.625.18705ffa8u4lwj：\n\n导入依赖：\n\n~~~xml\n<dependency>\n    <groupId>com.aliyun</groupId>\n    <artifactId>dysmsapi20170525</artifactId>\n    <version>2.0.1</version>\n</dependency>\n~~~\n\n~~~java\npackage com.tanhua.sso.service;\n\nimport com.aliyun.dysmsapi20170525.models.SendSmsRequest;\nimport com.aliyun.dysmsapi20170525.models.SendSmsResponse;\nimport com.aliyun.dysmsapi20170525.models.SendSmsResponseBody;\nimport com.aliyun.teaopenapi.models.Config;\n\npublic class SendSms {\n\n    /**\n     * 使用AK&SK初始化账号Client\n     * @param accessKeyId\n     * @param accessKeySecret\n     * @return Client\n     * @throws Exception\n     */\n    public static com.aliyun.dysmsapi20170525.Client createClient(String accessKeyId, String accessKeySecret) throws Exception {\n        Config config = new Config()\n                // 您的AccessKey ID\n                .setAccessKeyId(accessKeyId)\n                // 您的AccessKey Secret\n                .setAccessKeySecret(accessKeySecret)\n                .setEndpoint(\"dysmsapi.aliyuncs.com\");\n        // 访问的域名\n        return new com.aliyun.dysmsapi20170525.Client(config);\n    }\n\n    public static void main(String[] args_) throws Exception {\n        java.util.List<String> args = java.util.Arrays.asList(args_);\n        com.aliyun.dysmsapi20170525.Client client = SendSms\n                .createClient(\"**********\", \"**********\");\n\n        SendSmsRequest sendSmsRequest = new SendSmsRequest()\n                .setPhoneNumbers( \"158****7944\") //目标手机号\n                .setSignName(\"ABC商城\") //签名名称\n                .setTemplateCode(\"SMS_204756062\") //短信模板code\n                .setTemplateParam(\"{\\\"code\\\":\\\"1111\\\"}\"); //模板中变量替换\n        SendSmsResponse sendSmsResponse = client.sendSms(sendSmsRequest);\n\n        SendSmsResponseBody body = sendSmsResponse.getBody();\n\n        // code = OK 代表成功\n        System.out.println(body.getCode() + \"  \" + body.getMessage());\n    }\n\n}\n~~~\n\n##### 3.6.1.4、实现发送短信方法\n\n配置文件：aliyun.properties\n\n~~~properties\naliyun.sms.accessKeyId = ***********\naliyun.sms.accessKeySecret = ***********\naliyun.sms.domain= dysmsapi.aliyuncs.com\naliyun.sms.signName= ABC商城\naliyun.sms.templateCode= SMS_204756062\n~~~\n\n需要注意中文编码问题：\n\n![image-20201016203847636](image-20201016203847636.png)\n\n读取配置：\n\n~~~java\npackage com.tanhua.sso.config;\n\nimport lombok.Data;\nimport org.springframework.boot.context.properties.ConfigurationProperties;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.context.annotation.PropertySource;\n\n@Configuration\n@PropertySource(\"classpath:aliyun.properties\")\n@ConfigurationProperties(prefix = \"aliyun.sms\")\n@Data\npublic class AliyunSMSConfig {\n\n    private String accessKeyId;\n    private String accessKeySecret;\n    private String domain;\n    private String signName;\n    private String templateCode;\n\n}\n~~~\n\n代码实现：\n\n~~~java\npackage com.tanhua.sso.service;\n\nimport cn.hutool.core.util.RandomUtil;\nimport cn.hutool.core.util.StrUtil;\nimport com.aliyun.dysmsapi20170525.Client;\nimport com.aliyun.dysmsapi20170525.models.SendSmsRequest;\nimport com.aliyun.dysmsapi20170525.models.SendSmsResponse;\nimport com.aliyun.dysmsapi20170525.models.SendSmsResponseBody;\nimport com.aliyun.teaopenapi.models.Config;\nimport com.tanhua.sso.config.AliyunSMSConfig;\nimport lombok.extern.slf4j.Slf4j;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.stereotype.Service;\n\n@Service\n@Slf4j\npublic class SmsService {\n\n    @Autowired\n    private AliyunSMSConfig aliyunSMSConfig;\n\n    /**\n     * 发送短信验证码\n     *\n     * @param mobile\n     * @return\n     */\n    public String sendSms(String mobile) {\n        //随机生成6位数字验证码\n        String code = RandomUtil.randomNumbers(6);\n        try {\n            Config config = new Config()\n                    .setAccessKeyId(this.aliyunSMSConfig.getAccessKeyId())\n                    .setAccessKeySecret(this.aliyunSMSConfig.getAccessKeySecret())\n                    .setEndpoint(this.aliyunSMSConfig.getDomain());\n\n            Client client = new Client(config);\n            SendSmsRequest sendSmsRequest = new SendSmsRequest()\n                    .setPhoneNumbers(mobile)//目标手机号\n                    .setSignName(this.aliyunSMSConfig.getSignName()) //签名名称\n                    .setTemplateCode(this.aliyunSMSConfig.getTemplateCode()) //短信模板code\n                    .setTemplateParam(\"{\\\"code\\\":\\\"\" + code + \"\\\"}\"); //模板中变量替换\n            SendSmsResponse sendSmsResponse = client.sendSms(sendSmsRequest);\n            SendSmsResponseBody body = sendSmsResponse.getBody();\n            if (StrUtil.equals(\"OK\", body.getCode())) {\n                return code;\n            }\n        } catch (Exception e) {\n            log.error(\"发送短信验证码失败！\" + mobile, e);\n        }\n        return null;\n    }\n}\n\n~~~\n\n### 6.2、模板组件\n\n企业开发中，往往将常见工具类封装抽取，以简洁便利的方式供其他工程模块使用。而SpringBoot的自动装配机制可以方便的实现组件抽取。SpringBoot执行流程如下\n\n1. 扫描依赖模块中META-INF/spring.factories\n2. 执行装配类中方法\n3. 对象存入容器中\n4. 核心工程注入对象，调用方法使用\n\n#### 6.2.1、配置类\n\ntanhua-autoconfig创建配置信息类\n\n```java\n@Data\n@ConfigurationProperties(prefix = \"tanhua.sms\")\npublic class SmsProperties {\n    private String signName;\n    private String templateCode;\n    private String accessKey;\n    private String secret;\n}\n```\n\n#### 6.2.2、发送短信模板对象\n\ntanhua-autoconfig创建模板对象对象发送信息\n\n```java\npackage com.tanhua.autoconfig.template;\n\nimport com.aliyun.dysmsapi20170525.models.SendSmsRequest;\nimport com.aliyun.dysmsapi20170525.models.SendSmsResponse;\nimport com.aliyun.dysmsapi20170525.models.SendSmsResponseBody;\nimport com.aliyun.teaopenapi.models.Config;\nimport com.tanhua.autoconfig.properties.SmsProperties;\n\npublic class SmsTemplate {\n\n    private SmsProperties properties;\n\n    public SmsTemplate(SmsProperties properties) {\n        this.properties = properties;\n    }\n\n    public void sendSms(String mobile,String code) {\n\n        try {\n            //配置阿里云\n            Config config = new Config()\n                    // 您的AccessKey ID\n                    .setAccessKeyId(properties.getAccessKey())\n                    // 您的AccessKey Secret\n                    .setAccessKeySecret(properties.getSecret());\n            // 访问的域名\n            config.endpoint = \"dysmsapi.aliyuncs.com\";\n\n            com.aliyun.dysmsapi20170525.Client client =  new com.aliyun.dysmsapi20170525.Client(config);\n\n            SendSmsRequest sendSmsRequest = new SendSmsRequest()\n                    .setPhoneNumbers(mobile)\n                    .setSignName(properties.getSignName())\n                    .setTemplateCode(properties.getTemplateCode())\n                    .setTemplateParam(\"{\\\"code\\\":\\\"\"+code+\"\\\"}\");\n            // 复制代码运行请自行打印 API 的返回值\n            SendSmsResponse response = client.sendSms(sendSmsRequest);\n\n            SendSmsResponseBody body = response.getBody();\n\n            System.out.println(body.getMessage());\n\n        }catch (Exception e) {\n            e.printStackTrace();\n        }\n\n    }\n\n}\n```\n\n#### 6.2.3、自动装配类\n\ntanhua-autoconfig创建自动装配的配置类\n\n```java\npackage com.tanhua.autoconfig;\n\n\nimport com.tanhua.autoconfig.properties.*;\nimport com.tanhua.autoconfig.template.*;\nimport org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;\nimport org.springframework.boot.context.properties.EnableConfigurationProperties;\nimport org.springframework.context.annotation.Bean;\n\n@EnableConfigurationProperties({\n        SmsProperties.class\n})\npublic class TanhuaAutoConfiguration {\n\n    @Bean\n    public SmsTemplate smsTemplate(SmsProperties properties) {\n        return new SmsTemplate(properties);\n    }\n}\n```\n\n#### 6.2.4、自动装配配置\n\n根据自动装配原则，在tanhua-autoconfig工程创建 /META-INF/spring.factories文件\n\n```properties\norg.springframework.boot.autoconfigure.EnableAutoConfiguration=\\\ncom.tanhua.autoconfig.TanhuaAutoConfiguration\n```\n\n#### 6.2.5、测试\n\ntanhua-app-server工程加入短信配置\n\n```yaml\ntanhua:\n  sms:\n    signName: 物流云商\n    templateCode: SMS_106590012\n    accessKey: LTAI4GKgob9vZ53k2SZdyAC7\n    secret: LHLBvXmILRoyw0niRSBuXBZewQ30la\n```\n\n编写单元测试类\n\n```java\n@RunWith(SpringRunner.class)\n@SpringBootTest(classes = AppServerApplication.class)\npublic class SmsTemplateTest {\n\n    //注入\n    @Autowired\n    private SmsTemplate smsTemplate;\n\n    //测试\n    @Test\n    public void testSendSms() {\n        smsTemplate.sendSms(\"18618412321\",\"4567\");\n    }\n}\n```\n\n#### 3.6.2、SSO短信接口服务\n\n##### 3.6.2.1、mock接口\n\n地址：https://mock-java.itheima.net/project/35/interface/api/581\n\n![1564535110994](1564535110994.png)\n\n##### 3.6.2.2、编写接口服务\n\n编写ErrorResult，ErrorResult对象是与前端约定好的结构，如果发生错误需要返回该对象，如果未发生错误响应200即可。\n\n~~~java\npackage com.tanhua.sso.vo;\n\nimport lombok.Builder;\nimport lombok.Data;\n\n@Data\n@Builder\npublic class ErrorResult {\n\n    private String errCode;\n    private String errMessage;\n}\n\n~~~\n\nSmsController：\n\n~~~java\npackage com.tanhua.sso.controller;\n\nimport com.tanhua.sso.service.SmsService;\nimport com.tanhua.sso.vo.ErrorResult;\nimport lombok.extern.slf4j.Slf4j;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.http.HttpStatus;\nimport org.springframework.http.ResponseEntity;\nimport org.springframework.web.bind.annotation.PostMapping;\nimport org.springframework.web.bind.annotation.RequestBody;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.RestController;\n\nimport java.util.Map;\n\n@RestController\n@RequestMapping(\"user\")\n@Slf4j\npublic class SmsController {\n\n    @Autowired\n    private SmsService smsService;\n\n    /**\n     * 发送短信验证码接口\n     *\n     * @param param\n     * @return\n     */\n    @PostMapping(\"login\")\n    public ResponseEntity<ErrorResult> sendCheckCode(@RequestBody Map<String, String> param) {\n        ErrorResult errorResult = null;\n        String phone = param.get(\"phone\");\n        try {\n            errorResult = this.smsService.sendCheckCode(phone);\n            if (null == errorResult) {\n                return ResponseEntity.ok(null);\n            }\n        } catch (Exception e) {\n            log.error(\"发送短信验证码失败~ phone = \" + phone, e);\n            errorResult = ErrorResult.builder().errCode(\"000002\").errMessage(\"短信验证码发送失败！\").build();\n        }\n        return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(errorResult);\n    }\n\n}\n\n~~~\n\nSmsService：\n\n~~~java\npackage com.tanhua.sso.service;\n\nimport cn.hutool.core.util.RandomUtil;\nimport cn.hutool.core.util.StrUtil;\nimport com.aliyun.dysmsapi20170525.Client;\nimport com.aliyun.dysmsapi20170525.models.SendSmsRequest;\nimport com.aliyun.dysmsapi20170525.models.SendSmsResponse;\nimport com.aliyun.dysmsapi20170525.models.SendSmsResponseBody;\nimport com.aliyun.teaopenapi.models.Config;\nimport com.tanhua.sso.config.AliyunSMSConfig;\nimport com.tanhua.sso.vo.ErrorResult;\nimport lombok.extern.slf4j.Slf4j;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.data.redis.core.RedisTemplate;\nimport org.springframework.stereotype.Service;\n\nimport java.time.Duration;\n\n@Service\n@Slf4j\npublic class SmsService {\n\n    @Autowired\n    private AliyunSMSConfig aliyunSMSConfig;\n\n    @Autowired\n    private RedisTemplate<String, String> redisTemplate;\n\n    /**\n     * 发送短信验证码\n     *\n     * @param mobile\n     * @return\n     */\n    public String sendSms(String mobile) {\n        //随机生成6位数字验证码\n        String code = RandomUtil.randomNumbers(6);\n        try {\n            Config config = new Config()\n                    .setAccessKeyId(this.aliyunSMSConfig.getAccessKeyId())\n                    .setAccessKeySecret(this.aliyunSMSConfig.getAccessKeySecret())\n                    .setEndpoint(this.aliyunSMSConfig.getDomain());\n\n            Client client = new Client(config);\n            SendSmsRequest sendSmsRequest = new SendSmsRequest()\n                    .setPhoneNumbers(mobile)//目标手机号\n                    .setSignName(this.aliyunSMSConfig.getSignName()) //签名名称\n                    .setTemplateCode(this.aliyunSMSConfig.getTemplateCode()) //短信模板code\n                    .setTemplateParam(\"{\\\"code\\\":\\\"\" + code + \"\\\"}\"); //模板中变量替换\n            SendSmsResponse sendSmsResponse = client.sendSms(sendSmsRequest);\n            SendSmsResponseBody body = sendSmsResponse.getBody();\n            if (StrUtil.equals(\"OK\", body.getCode())) {\n                return code;\n            }\n        } catch (Exception e) {\n            log.error(\"发送短信验证码失败！\" + mobile, e);\n        }\n        return null;\n    }\n\n    /**\n     * 发送短信验证码\n     * 实现：发送完成短信验证码后，需要将验证码保存到redis中\n     * @param phone\n     * @return\n     */\n    public ErrorResult sendCheckCode(String phone) {\n        String redisKey = \"CHECK_CODE_\" + phone;\n\n        //先判断该手机号发送的验证码是否还未失效\n        if(this.redisTemplate.hasKey(redisKey)){\n            String msg = \"上一次发送的验证码还未失效！\";\n            return ErrorResult.builder().errCode(\"000001\").errMessage(msg).build();\n        }\n\n        String code = this.sendSms(phone);\n        if(StrUtil.isEmpty(code)){\n            String msg = \"发送短信验证码失败！\";\n            return ErrorResult.builder().errCode(\"000000\").errMessage(msg).build();\n        }\n\n        //短信发送成功，将验证码保存到redis中，有效期为5分钟\n        this.redisTemplate.opsForValue().set(redisKey, code, Duration.ofMinutes(5));\n\n        return null;\n    }\n}\n\n~~~\n\n## 7、用户登录\n\n### 7.1、登录验证码\n\n![image-20210714115937330](image-20210714115937330.png)\n\n#### 7.1.1、接口说明\n\n![image-20210714120045422](image-20210714120045422.png)\n\n参见YAPI接口地址：http://192.168.136.160:3000/project/19/interface/api/94\n\n#### 7.1.2、流程分析\n\n![image-20210714120354128](image-20210714120354128.png)\n\n客户端发送请求\n\n服务端调用第三方组件发送验证码\n\n验证码发送成功，存入redis\n\n响应客户端，客户端跳转到输入验证码页面\n\n#### 7.1.3、代码实现\n\n##### **LoginController**\n\n```java\n@RestController\n@RequestMapping(\"/user\")\npublic class LoginController {\n\n    @Autowired\n    private UserService userService;\n\n    /**\n     * 获取登录验证码\n     *   请求参数：phone （Map）\n     *   响应：void\n     */\n    @PostMapping(\"/login\")\n    public ResponseEntity login(@RequestBody Map map){\n        String phone =(String) map.get(\"phone\");\n        userService.sendMsg(phone);\n        return ResponseEntity.ok(null); //正常返回状态码200\n    }\n}\n```\n\n##### UserService\n\n```java\n@Service\npublic class UserService {\n\n    @Autowired\n    private SmsTemplate template;\n\n    @Autowired\n    private RedisTemplate<String,String> redisTemplate;\n\n    /**\n     * 发送短信验证码\n     * @param phone\n     */\n    public void sendMsg(String phone) {\n        //1、随机生成6位数字\n        //String code = RandomStringUtils.randomNumeric(6);\n        String code = \"123456\";\n        //2、调用template对象，发送手机短信\n        //template.sendSms(phone,code);\n        //3、将验证码存入到redis\n        redisTemplate.opsForValue().set(\"CHECK_CODE_\"+phone,code, Duration.ofMinutes(5));\n    }\n }\n```\n\n### 7.2、JWT\n\n#### 7.2.1、简介\n\nJSON Web token简称JWT， 是用于对应用程序上的用户进行身份验证的标记。也就是说, 使用 JWTS 的应用程序不再需要保存有关其用户的 cookie 或其他session数据。此特性便于可伸缩性, 同时保证应用程序的安全\n\n#### 7.2.2、格式\n\n* JWT就是一个字符串，经过加密处理与校验处理的字符串，形式为：A.B.C\n\n* A由JWT头部信息header加密得到\n\n* B由JWT用到的身份验证信息json数据加密得到\n\n* C由A和B加密得到，是校验部分\n\n![image-20210714121154190](image-20210714121154190.png)\n\n\n#### 7.2.3、流程\n\n![image-20210714121203246](image-20210714121203246.png)\n\n#### 7.2.4、示例\n\n导入依赖：\n\n~~~xml\n<dependency>\n    <groupId>io.jsonwebtoken</groupId>\n    <artifactId>jjwt</artifactId>\n    <version>0.9.1</version>\n</dependency>\n~~~\n\n编写测试用例：\n\n~~~java\n    @Test\n    public void testCreateToken() {\n        //生成token\n        //1、准备数据\n        Map map = new HashMap();\n        map.put(\"id\",1);\n        map.put(\"mobile\",\"13800138000\");\n        //2、使用JWT的工具类生成token\n        long now = System.currentTimeMillis();\n        String token = Jwts.builder()\n                .signWith(SignatureAlgorithm.HS512, \"itcast\") //指定加密算法\n                .setClaims(map) //写入数据\n                .setExpiration(new Date(now + 30000)) //失效时间\n                .compact();\n        System.out.println(token);\n    }\n\n    //解析token\n\n    /**\n     * SignatureException : token不合法\n     * ExpiredJwtException：token已过期\n     */\n    @Test\n    public void testParseToken() {\n        String token = \"eyJhbGciOiJIUzUxMiJ9.eyJtb2JpbGUiOiIxMzgwMDEzODAwMCIsImlkIjoxLCJleHAiOjE2MTgzOTcxOTV9.2lQiovogL5tJa0px4NC-DW7zwHFqZuwhnL0HPAZunieGphqnMPduMZ5TtH_mxDrgfiskyAP63d8wzfwAj-MIVw\";\n        try {\n            Claims claims = Jwts.parser()\n                    .setSigningKey(\"itcast\")\n                    .parseClaimsJws(token)\n                    .getBody();\n            Object id = claims.get(\"id\");\n            Object mobile = claims.get(\"mobile\");\n            System.out.println(id + \"--\" + mobile);\n        }catch (ExpiredJwtException e) {\n            System.out.println(\"token已过期\");\n        }catch (SignatureException e) {\n            System.out.println(\"token不合法\");\n        }\n\n    }\n~~~\n\n通过解析Token得知，如果抛出SignatureException异常表示token不合法，如果抛出ExpiredJwtException异常表示token已过期\n\n#### 7.2.5 JWT工具类\n\n```java\npublic class JwtUtils {\n\n    // TOKEN的有效期1小时（S）\n    private static final int TOKEN_TIME_OUT = 1 * 3600;\n\n    // 加密KEY\n    private static final String TOKEN_SECRET = \"itcast\";\n\n\n    // 生成Token\n    public static String getToken(Map params){\n        long currentTime = System.currentTimeMillis();\n        return Jwts.builder()\n                .signWith(SignatureAlgorithm.HS512, TOKEN_SECRET) //加密方式\n                .setExpiration(new Date(currentTime + TOKEN_TIME_OUT * 1000)) //过期时间戳\n                .addClaims(params)\n                .compact();\n    }\n\n\n    /**\n     * 获取Token中的claims信息\n     */\n    public static Claims getClaims(String token) {\n        return Jwts.parser()\n                .setSigningKey(TOKEN_SECRET)\n                .parseClaimsJws(token).getBody();\n    }\n\n\n    /**\n     * 是否有效 true-有效，false-失效\n     */\n    public static boolean verifyToken(String token) {\n      \n        if(StringUtils.isEmpty(token)) {\n            return false;\n        }\n        \n        try {\n            Claims claims = Jwts.parser()\n                    .setSigningKey(\"itcast\")\n                    .parseClaimsJws(token)\n                    .getBody();\n        }catch (Exception e) {\n            return false;\n        }\n\n      return true;\n    }\n}\n```\n\n### 7.3、用户登录\n\n用户接收到验证码后，进行输入验证码，点击登录，前端系统将手机号以及验证码提交到服务端进行校验。\n\n![image-20210714121439345](image-20210714121439345.png)\n\n#### 7.3.1、接口文档\n\n![image-20210714121642629](image-20210714121642629.png)\n\nYAPI接口地址：https://mock-java.itheima.net/project/164/interface/api/12593\n\n#### 7.3.2、LoginController\n\n~~~java\n    /**\n     * 检验登录\n     */\n    @PostMapping(\"/loginVerification\")\n    public ResponseEntity loginVerification(@RequestBody Map map) {\n        //1、调用map集合获取请求参数\n        String phone = (String) map.get(\"phone\");\n        String code = (String) map.get(\"verificationCode\");\n        //2、调用userService完成用户登录\n        Map retMap = userService.loginVerification(phone,code);\n        //3、构造返回\n        return ResponseEntity.ok(retMap);\n    }\n~~~\n\n#### 7.3.3、UserService\n\n~~~java\n    /**\n     * 验证登录\n     * @param phone\n     * @param code\n     */\n    public Map loginVerification(String phone, String code) {\n        //1、从redis中获取下发的验证码\n        String redisCode = redisTemplate.opsForValue().get(\"CHECK_CODE_\" + phone);\n        //2、对验证码进行校验（验证码是否存在，是否和输入的验证码一致）\n        if(StringUtils.isEmpty(redisCode) || !redisCode.equals(code)) {\n            //验证码无效\n             throw new RuntimeException();\n        }\n        //3、删除redis中的验证码\n        redisTemplate.delete(\"CHECK_CODE_\" + phone);\n        //4、通过手机号码查询用户\n        User user = userApi.findByMobile(phone);\n        boolean isNew = false;\n        //5、如果用户不存在，创建用户保存到数据库中\n        if(user == null) {\n            user = new User();\n            user.setMobile(phone);\n            user.setPassword(DigestUtils.md5Hex(\"123456\"));\n            Long userId = userApi.save(user);\n            user.setId(userId);\n            isNew = true;\n        }\n        //6、通过JWT生成token(存入id和手机号码)\n        Map tokenMap = new HashMap();\n        tokenMap.put(\"id\",user.getId());\n        tokenMap.put(\"mobile\",phone);\n        String token = JwtUtils.getToken(tokenMap);\n        //7、构造返回值\n        Map retMap = new HashMap();\n        retMap.put(\"token\",token);\n        retMap.put(\"isNew\",isNew);\n\n        return retMap;\n    }\n~~~\n\n#### 7.3.4、测试\n\n![1564300534797](1564300534797.png)\n\n## 8、代码优化\n\n### 8.1 抽取BasePojo\n\n为了简化实体类中created和updated字段，抽取BasePojo\n\n```java\n@Data\npublic abstract class BasePojo implements Serializable {\n\n    @TableField(fill = FieldFill.INSERT) //自动填充\n    private Date created;\n    @TableField(fill = FieldFill.INSERT_UPDATE)\n    private Date updated;\n\n}\n```\n\n### 8.2 自动填充\n\n对于created和updated字段，每次操作都需要手动设置。为了解决这个问题，mybatis-plus支持自定义处理器的形式实现保存更新的自动填充\n\n```java\npackage com.tanhua.dubbo.server.handler;\n\nimport com.baomidou.mybatisplus.core.handlers.MetaObjectHandler;\nimport org.apache.ibatis.reflection.MetaObject;\nimport org.springframework.stereotype.Component;\n\nimport java.util.Date;\n\n@Component\npublic class MyMetaObjectHandler implements MetaObjectHandler {\n\n    @Override\n    public void insertFill(MetaObject metaObject) {\n        Object created = getFieldValByName(\"created\", metaObject);\n        if (null == created) {\n            //字段为空，可以进行填充\n            setFieldValByName(\"created\", new Date(), metaObject);\n        }\n\n        Object updated = getFieldValByName(\"updated\", metaObject);\n        if (null == updated) {\n            //字段为空，可以进行填充\n            setFieldValByName(\"updated\", new Date(), metaObject);\n        }\n    }\n\n    @Override\n    public void updateFill(MetaObject metaObject) {\n        //更新数据时，直接更新字段\n        setFieldValByName(\"updated\", new Date(), metaObject);\n    }\n}\n```\n\n\n","tags":["项目","学习"],"categories":["Java","项目整理","某马XX交友项目技术与业务整理"]},{"title":"MyBatis批量插入Oracle报错","url":"/2022/11/24/MyBatis批量插入Oracle报错/","content":"\n## MyBatis\n\n### Oracle数据库批量插入\n> **问题描述**: 我想一次性插入多条记录，数据库使用的oracle,crud框架为mybatis。出现【SQL 命令未正确结束】的错误。\n\n> MyBatis SQL 如下:\n``` sql\n<insert id=\"insertList\" parameterType=\"java.util.List\" useGeneratedKeys=\"false\">\n    insert into TD_S_LONGSHORTLINK_JT (LINK_ID, LONG_LINK, SHORT_LINK, \n      DEAL_TIME, DESC_INFO, BAK1, \n      BAK2, BAK3)\n     values\n     <foreach collection=\"list\" item=\"item\" index=\"index\" separator=\",\" >  \n         #{item.linkId,jdbcType=VARCHAR},\n         #{item.longLink,jdbcType=VARCHAR},\n         #{item.shortLink,jdbcType=VARCHAR},\n         #{item.dealTime,jdbcType=TIMESTAMP},\n         #{item.descInfo,jdbcType=VARCHAR},\n         #{item.bak1,jdbcType=VARCHAR},\n         #{item.bak2,jdbcType=VARCHAR},\n         #{item.bak3,jdbcType=VARCHAR} \n    </foreach> \n  </insert>\n```\n\n> 解决代码如下：\n```sql\n<insert id=\"insertList\" parameterType=\"java.util.List\" useGeneratedKeys=\"false\">\n    insert into TD_S_LONGSHORTLINK_JT (LINK_ID, LONG_LINK, SHORT_LINK, \n      DEAL_TIME, DESC_INFO, BAK1, \n      BAK2, BAK3)\n    <foreach collection=\"list\" item=\"item\" index=\"index\" separator=\"UNION\" >  \n        select \n            #{item.linkId,jdbcType=VARCHAR},\n            #{item.longLink,jdbcType=VARCHAR},\n            #{item.shortLink,jdbcType=VARCHAR},\n            #{item.dealTime,jdbcType=TIMESTAMP},\n            #{item.descInfo,jdbcType=VARCHAR},\n            #{item.bak1,jdbcType=VARCHAR},\n            #{item.bak2,jdbcType=VARCHAR},\n            #{item.bak3,jdbcType=VARCHAR} \n        from dual  \n    </foreach>  \n  </insert>\n```\n> **原因**:\n> 由于**oracle数据库搭配MyBatis框架不支持values**，所以只能使用 **sparator='UNION'**\n> 将插入的数据临时保存并连接起来一起插入\n","tags":["工作","遇坑"],"categories":["Java","Java框架"]},{"title":"Idea破解方法","url":"/2022/09/09/Idea破解方法/","content":"\n<font color=red>通过补丁可以永久激活 IDEA，前面 IDEA 安装方式都是一样的，主要是后面的步骤，注意看后面就行~</font>\n\n申明：本教程 IntelliJ IDEA 破解补丁、激活码均收集于网络，请勿商用，仅供个人学习使用，如有侵权，请联系作者删除。若条件允许，希望大家购买正版 ！\n\nPS: 本教程最新更新时间: 2022年09月09日~\n\nidea安装教程和冲突笔者不在这里赘述，百度都有解决方案，咱们直接开始后面的步骤~~~~\n\n# 一、 永久激活版\n- ### 下载激活脚本\n   ![Reference](破解文件列表.png)\n  打开文件夹后，目录如下，ja-netfilter.jar 为激活补丁：\n  ![Reference](ja-netifilter.png)\n- ### 复制补丁所在的整个文件夹到硬盘某个位置\n  <font color=red>必须是整个ja-netifilter文件夹，之后就不要移动和删除这个文件夹了,这里笔者是直接放在了D盘</font>\n- ### 引用激活补丁\n  进入 IDEA 的安装目录，笔者安装时，使用了默认安装路径，然后，进入 /bin 目录下，修改\n    `idea64.exe.vmoptions`配置文件:\n  ![Reference](idea64.exe.vmoptions.png)\n  在 `idea64.exe.vmoptions` 配置文件结尾添加如下配置：\n    ``` vmoptions\n    # 引用补丁，开头必须以 -javaagent: 开头，后面跟着补丁的绝对路径（可根据你实际的位置进行修改）,注意路径一定要填写正确，且不能包含中文，否则会导致 IDEA 无法启动\n    -javaagent:D:/ja-netfilter/ja-netfilter.jar\n    # 最新 IDEA 版本需要添加下面两行，以支持 Java 17, 否则会报 Key is invalid\n    --add-opens=java.base/jdk.internal.org.objectweb.asm=ALL-UNNAMED\n    --add-opens=java.base/jdk.internal.org.objectweb.asm.tree=ALL-UNNAMED\n    ```\n  ![Reference](vmoptions配置文件编辑.png)\n- 重启 IDEA\n\n  <font color=red>配置完成后保存，一定要重启 IDEA !!!</font>\n\n  <font color=red>配置完成后保存，一定要重启 IDEA !!!</font>\n- 重新打开 IDEA, 填入指定激活码点击激活完成激活\n  ```\n  ZCB571FZHV-eyJsaWNlbnNlSWQiOiJaQ0I1NzFGWkhWIiwibGljZW5zZWVOYW1lIjoiZnV6emVzIGFsbHkiLCJhc3NpZ25lZU5hbWUiOiIiLCJhc3NpZ25lZUVtYWlsIjoiIiwibGljZW5zZVJlc3RyaWN0aW9uIjoiIiwiY2hlY2tDb25jdXJyZW50VXNlIjpmYWxzZSwicHJvZHVjdHMiOlt7ImNvZGUiOiJQREIiLCJmYWxsYmFja0RhdGUiOiIyMDIzLTA3LTAxIiwicGFpZFVwVG8iOiIyMDIzLTA3LTAxIiwiZXh0ZW5kZWQiOnRydWV9LHsiY29kZSI6IlBTSSIsImZhbGxiYWNrRGF0ZSI6IjIwMjMtMDctMDEiLCJwYWlkVXBUbyI6IjIwMjMtMDctMDEiLCJleHRlbmRlZCI6dHJ1ZX0seyJjb2RlIjoiUFBDIiwiZmFsbGJhY2tEYXRlIjoiMjAyMy0wNy0wMSIsInBhaWRVcFRvIjoiMjAyMy0wNy0wMSIsImV4dGVuZGVkIjp0cnVlfSx7ImNvZGUiOiJQQ1dNUCIsImZhbGxiYWNrRGF0ZSI6IjIwMjMtMDctMDEiLCJwYWlkVXBUbyI6IjIwMjMtMDctMDEiLCJleHRlbmRlZCI6dHJ1ZX0seyJjb2RlIjoiUFBTIiwiZmFsbGJhY2tEYXRlIjoiMjAyMy0wNy0wMSIsInBhaWRVcFRvIjoiMjAyMy0wNy0wMSIsImV4dGVuZGVkIjp0cnVlfSx7ImNvZGUiOiJQUkIiLCJmYWxsYmFja0RhdGUiOiIyMDIzLTA3LTAxIiwicGFpZFVwVG8iOiIyMDIzLTA3LTAxIiwiZXh0ZW5kZWQiOnRydWV9LHsiY29kZSI6IklJIiwiZmFsbGJhY2tEYXRlIjoiMjAyMy0wNy0wMSIsInBhaWRVcFRvIjoiMjAyMy0wNy0wMSIsImV4dGVuZGVkIjpmYWxzZX0seyJjb2RlIjoiUEdPIiwiZmFsbGJhY2tEYXRlIjoiMjAyMy0wNy0wMSIsInBhaWRVcFRvIjoiMjAyMy0wNy0wMSIsImV4dGVuZGVkIjp0cnVlfSx7ImNvZGUiOiJQU1ciLCJmYWxsYmFja0RhdGUiOiIyMDIzLTA3LTAxIiwicGFpZFVwVG8iOiIyMDIzLTA3LTAxIiwiZXh0ZW5kZWQiOnRydWV9LHsiY29kZSI6IlBXUyIsImZhbGxiYWNrRGF0ZSI6IjIwMjMtMDctMDEiLCJwYWlkVXBUbyI6IjIwMjMtMDctMDEiLCJleHRlbmRlZCI6dHJ1ZX1dLCJtZXRhZGF0YSI6IjAxMjAyMjA3MDFQU0FOMDAwMDA1IiwiaGFzaCI6IlRSSUFMOi01OTQ5ODgxMjIiLCJncmFjZVBlcmlvZERheXMiOjcsImF1dG9Qcm9sb25nYXRlZCI6ZmFsc2UsImlzQXV0b1Byb2xvbmdhdGVkIjpmYWxzZX0=-JNpWl3tvfBw9nYALTrBlJzoryrKHhqmiBxP5IljC6Hlgmb6YlOH8vPngzoyLYa+cGDMVj6fipEpm+BEqIA7oAoBYSu1ZPdzkHAa94apJg+CUQwuw+EJaATdKTANuKYTBsay6WsnrUh8vbIaJpGz19z+uOAc4xRP+gtuyjiwkNECZ6Y9qD+Dx3Gm5xXI3UvKqjPYIhXk23n1pjlxFIUmhD7BumdxF8JHmJJhd/K5FaXQU/K9pMp70GfmSS2KJgxm6SXfslWs/bF5GTY3i1GA6ez05ZyJwsmJMZ1v6W7GWrWNHDLK7i7aXhOLdK9u+pCz+2FpKmadRznpSmixDzj37ig==-MIIETDCCAjSgAwIBAgIBDTANBgkqhkiG9w0BAQsFADAYMRYwFAYDVQQDDA1KZXRQcm9maWxlIENBMB4XDTIwMTAxOTA5MDU1M1oXDTIyMTAyMTA5MDU1M1owHzEdMBsGA1UEAwwUcHJvZDJ5LWZyb20tMjAyMDEwMTkwggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQCUlaUFc1wf+CfY9wzFWEL2euKQ5nswqb57V8QZG7d7RoR6rwYUIXseTOAFq210oMEe++LCjzKDuqwDfsyhgDNTgZBPAaC4vUU2oy+XR+Fq8nBixWIsH668HeOnRK6RRhsr0rJzRB95aZ3EAPzBuQ2qPaNGm17pAX0Rd6MPRgjp75IWwI9eA6aMEdPQEVN7uyOtM5zSsjoj79Lbu1fjShOnQZuJcsV8tqnayeFkNzv2LTOlofU/Tbx502Ro073gGjoeRzNvrynAP03pL486P3KCAyiNPhDs2z8/COMrxRlZW5mfzo0xsK0dQGNH3UoG/9RVwHG4eS8LFpMTR9oetHZBAgMBAAGjgZkwgZYwCQYDVR0TBAIwADAdBgNVHQ4EFgQUJNoRIpb1hUHAk0foMSNM9MCEAv8wSAYDVR0jBEEwP4AUo562SGdCEjZBvW3gubSgUouX8bOhHKQaMBgxFjAUBgNVBAMMDUpldFByb2ZpbGUgQ0GCCQDSbLGDsoN54TATBgNVHSUEDDAKBggrBgEFBQcDATALBgNVHQ8EBAMCBaAwDQYJKoZIhvcNAQELBQADggIBABqRoNGxAQct9dQUFK8xqhiZaYPd30TlmCmSAaGJ0eBpvkVeqA2jGYhAQRqFiAlFC63JKvWvRZO1iRuWCEfUMkdqQ9VQPXziE/BlsOIgrL6RlJfuFcEZ8TK3syIfIGQZNCxYhLLUuet2HE6LJYPQ5c0jH4kDooRpcVZ4rBxNwddpctUO2te9UU5/FjhioZQsPvd92qOTsV+8Cyl2fvNhNKD1Uu9ff5AkVIQn4JU23ozdB/R5oUlebwaTE6WZNBs+TA/qPj+5/we9NH71WRB0hqUoLI2AKKyiPw++FtN4Su1vsdDlrAzDj9ILjpjJKA1ImuVcG329/WTYIKysZ1CWK3zATg9BeCUPAV1pQy8ToXOq+RSYen6winZ2OO93eyHv2Iw5kbn1dqfBw1BuTE29V2FJKicJSu8iEOpfoafwJISXmz1wnnWL3V/0NxTulfWsXugOoLfv0ZIBP1xH9kmf22jjQ2JiHhQZP7ZDsreRrOeIQ/c4yR8IQvMLfC0WKQqrHu5ZzXTH4NO3CwGWSlTY74kE91zXB5mwWAx1jig+UXYc2w4RkVhy0//lOmVya/PEepuuTTI4+UJwC7qbVlh5zfhj8oTNUXgN0AOc+Q0/WFPl1aw5VV/VrO8FCoB15lFVlpKaQ1Yh+DVU8ke+rt9Th0BCHXe0uZOEmH0nOnH/0onD\n  ```\n- 成功页面\n\n![Reference](激活成功页面.png)\n\n<font color=red>一切按照教程来的，还是提示 Key is invalid？</font>\n- 1. 部分小伙伴不仔细看教程，激活过程中只复制了 ja-netfilter.jar 一个文件，结果输入激活码时报 Key is invalid, 注意是所在的整个文件夹都需要复制，然后再引用补丁，而不是仅仅复制一个 ja-netfilter.jar 文件；\n- 2. 配置文件中，引用补丁必须以 -javaagent: 开头，后面跟着补丁的绝对路径，开头不能丢，否则无法引用破解补丁成功；\n- 3. 检查引用的补丁路径中是否包含中文，需要全英文才行；\n- 4. 笔者亲测的版本 2022.2.1、2022.1、2021.3.3、2021.3.2 都是可以的，确认你的版本号是否是最新的这些版本，太老的版本请用下方第二种方法：无限重置 IDEA 30 天试用期；\n- 5. 部分小伙伴反馈说重启系统后，才激活成功的，这种法子也可以尝试一下；\n- 6. 检查破解补丁的位置是否动了，切记不要动，不然重启 IDE 又找不到补丁位置了，自然就失败了；\n\n### <font color=red> 激活成功后，不要升级 IDEA 版本</font>\n\n# 二、 30天无限试用插件版\n- 将ide-eval-resetter-2.1.6插件包直接拖进idea中安装然后重启idea\n\n  ![Reference](ide-eval-resetter-2.1.6.png)\n\n  ![Reference](ide-eval启用.png)\n- 接着点击该插件的reset重置即可试用30天\n## 附破解包from百度网盘:\n## [破解包](https://pan.baidu.com/s/1YTc2CFHbSXz8Jbvo_S9_Jw  \"JetBrains2022最新全家桶激活(7.30).zip\") 密码:18cm\n","tags":["软件分享","Idea","破解"],"categories":["杂七杂八","软件安利"]},{"title":"Hello World","url":"/2022/09/09/hello-world/","content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n"},{"title":"Java-引用","url":"/2022/09/06/Java-引用/","content":"\n# 数据类型\n\nJava里将数据类型分为了基本数据类型和引用数据类型，基本数据类型包含: byte、char、short、int、float、double、long、boolean，剩下的都是引用类型。最常用的就是String字符串：\n- 基本数据类型的值都是直接保存在变量中的(一个变量一个值，可以体会到类似Integer.valueof缓存值的用意)\n- 而引用类型的变量类似于C语言的指针，它内部存储一个“地址”，指向某个对象在内存的位置\n- 对于基本类型变量num，赋值运算符将会直接修改变量的值，原来的数据将被覆盖掉，被替换为新的值。\n- 对于引用类型变量str，赋值运算符只会改变变量中所保存的**对象的地址**信息，原来对象的地址被覆盖掉，重新写入新对象的地址数据。但**原来的对象本身并不会被改变**，只是不再被任何引用所指向的对象，即“垃圾对象”，后续会被垃圾回收器回收。\n- 引用类型的变量可以指向一个空值null，它表示不存在，即该变量不指向任何对象\n\n基本类型的变量是“持有”某个数值，引用类型的变量是“指向”某个对象\n\n<!-- more -->\n\n``` java\n    public static void main(String[] args) {\n        int num = 1;\n        int num2 = num;\n        System.out.println(\"num修改前: \" + num + \" num2: \" + num2);\n        num = 2;\n        System.out.println(\"num修改后: \" + num + \" num2: \" + num2);\n\n        System.out.println(\"=======================\");\n        StringBuilder sb =  new StringBuilder(\"hello\");\n        StringBuilder sb2 = sb;\n        System.out.println(\"sb修改前: \" + sb.toString() + \" sb2: \" + sb2.toString());\n        sb.append(\" world\");\n        System.out.println(\"sb修改后: \" + sb.toString() + \" sb2: \" + sb2.toString());\n\n        System.out.println(\"=======================\");\n        String str = \"hello\";\n        String str2 = str;\n        System.out.println(\"str修改前: \" + str + \" str2: \" + str2);\n        str = \"world\";\n        System.out.println(\"str修改后: \" + str + \" str2: \" + str2);\n\n    }\n\n\n//输出\nnum修改前: 1 num2: 1\nnum修改后: 2 num2: 1\n=======================\nsb修改前: hello sb2: hello\nsb修改后: hello world sb2: hello world\n=======================\nstr修改前: hello str2: hello\nstr修改后: world str2: hello\n```\n\n> 这里可以联想下String的不可变性\n\n## 参数传递\n\nJava的参数传递为值传递。也就是说，当我们传递一个参数时，方法将获得该参数的一个拷贝:\n\n- 基本类型变量的值传递，意味着变量本身被复制，并传递给Java方法。Java方法对变量的修改不会影响到原变量。\n- 引用的值传递，意味着对象的地址被复制，并传递给Java方法。Java方法根据该引用的访问将会影响对象\n\n``` Java\npublic class Test {\n\n    public static void main(String[] args) {\n        int num = 1;\n        System.out.println(\"num修改前: \" + num);\n        testIntArg(num);\n        System.out.println(\"num修改后: \" + num);\n\n        System.out.println(\"=======================\");\n        StringBuilder sb =  new StringBuilder(\"hello\");\n        System.out.println(\"sb修改前: \" + sb.toString());\n        testSbArg(sb);\n        System.out.println(\"sb修改后: \" + sb.toString());\n\n        System.out.println(\"=======================\");\n        String str = \"hello\";\n        System.out.println(\"str修改前: \" + str);\n        testStrArg(str);\n        System.out.println(\"str修改后: \" + str);\n\n    }\n\n    public static void testIntArg(int num) {\n        //基本数据类型，参数传递后，方法内部修改不会影响原有参数\n        System.out.println(\"testIntArg, num修改前: \" + num);\n        num = 2;\n        System.out.println(\"testIntArg,num修改后: \" + num);\n    }\n\n    public static void testSbArg(StringBuilder sb) {\n        //引用数据类型，参数传递后，除非重新new对象，否则方法内部修改会影响原有参数\n        System.out.println(\"testSbArg, sb修改前: \" + sb.toString());\n        sb.append(\" world\");\n        System.out.println(\"testSbArg, sb修改后: \" + sb.toString());\n    }\n\n    public static void testStrArg(String str) {\n        System.out.println(\"testStrArg, str修改前: \" + str);\n        //String 这里就相当于new String()了\n        str = \"hello world\";\n        System.out.println(\"testStrArg, str修改后: \" + str);\n    }\n\n}\n\n//输出\nnum修改前: 1\ntestIntArg, num修改前: 1\ntestIntArg,num修改后: 2\nnum修改后: 1\n=======================\nsb修改前: hello\ntestSbArg, sb修改前: hello\ntestSbArg, sb修改后: hello world\nsb修改后: hello world\n=======================\nstr修改前: hello\ntestStrArg, str修改前: hello\ntestStrArg, str修改后: hello world\nstr修改后: hello\n```\n\n# 引用类型\n\n\nJava提供了四种引用类型：强引用(FinalReference)、软引用(SoftReference)、弱引用(WeakReference)、虚引用(PhantomReference)\n\n![Reference](Reference.png)\n\n除了强引用(FinalReference)其他都是public修饰的，可以在我们的程序里直接使用，事实如果我们直接定义变量等某个对象时，默认就是对这个对象的强引用\n\n## 强引用\n\n强引用特点：\n\n- 强引用可以直接访问目标对象\n- 只要有引用变量存在，垃圾回收器永远不会回收。JVM即使抛出OOM异常，也不会回收强引用所指向的对象。\n+ 强引用可能导致内存泄漏问\n\n强引用是使用最普遍的引用。如果一个对象具有强引用，那么垃圾回收器**绝不会回收**它。例如:StringBuilder sb = new StringBuilder(\"test\");变量str指向StringBuffer实例所在的堆空间，通过str可以操作该对象。\n\n在不用对象的时将引用赋值为 null，能够帮助垃圾回收器回收对象(具体回收时机还是要看垃圾收集策略)。比如 ArrayList 的 clear() 方法实现：\n\n``` Java\n    public void clear() {\n        modCount++;\n        final Object[] es = elementData;\n        for (int to = size, i = size = 0; i < to; i++)\n            es[i] = null;\n    }\n```\n\n## 软引用\n\n软引用是用来描述一些有用但并不是必需的对象。对于软引用关联着的对象，在系统将要发生内存溢出异常之前，将会把这些对象列进回首范围之中进行第二次回收。如果这次回收还没有足够的内存，才会抛出内存溢出异常。\n\n因此，软引用可以用于实现**对内存敏感的高速缓存**: 在内存足够的情况下直接通过软引用取值，无需从的真实来源查询数据，提升速度；当内存不足时，自动删除这部分缓存数据，从真正的来源查询这些数据。\n\n软引用特点是它的一个实例保存对一个Java对象的软引用，该软引用的存在不妨碍垃圾收集线程对该Java对象的回收：\n- 在垃圾线程对这个Java对象回收前，SoftReference类所提供的get()方法返回Java对象的强引用\n- 在垃圾线程回收该Java对象之后，get()方法将返回null\n\n> 软引用对象是在jvm内存不够的时候才会被回收\n\n``` Java\npublic class SoftReferenceTest {\n\n    static class HeapObject {\n        byte[] bs = new byte[1024 * 1024];\n    }\n\n    public static void main(String[] args) {\n        SoftReference<HeapObject> softReference = new SoftReference<>(new HeapObject());\n\n        List<HeapObject> list = new ArrayList<>();\n\n        while (true) {\n            if (softReference.get() != null) {\n                //模拟消耗内存\n                list.add(new HeapObject());\n                System.out.println(\"list.add\");\n            } else {\n                System.out.println(\"---------软引用已被回收---------\");\n                break;\n            }\n            System.gc();\n        }\n    }\n}\n```\n\n实现简易版缓存\n\n``` Java\n/**\n * 简易版软引用实现的缓存\n */\npublic class SoftReferenceCache<K, V> {\n    private final HashMap<K, SoftReference<V>> mCache;\n\n    public SoftReferenceCache() {\n        mCache = new HashMap<K, SoftReference<V>>();\n    }\n\n    /**\n     * 将对象放进缓存中，这个对象可以在GC发生时被回收\n     * @param key key的值.\n     * @param value value的值型.\n     */\n    public void put(K key, V value) {\n        mCache.put(key, new SoftReference<V>(value));\n    }\n\n    /**\n     * 从缓存中获取value\n     * @param key\n     * @return 如果找到的话返回value，如果被回收或者没有就返回null\n     */\n    public V get(K key) {\n        V value = null;\n        SoftReference<V> reference = mCache.get(key);\n        if (reference != null) {\n            value = reference.get();\n        }\n\n        return value;\n    }\n}\n\n```\n\n## 弱引用\n\n弱引用是一种比软引用较弱的引用类型。在系统GC时，只要发现弱引用，不管系统堆空间是否足够，都会将对象进行回收。\n\n不过，由于垃圾回收器是一个优先级很低的线程，因此不一定会很快发现那些只具有弱引用的对象。弱引用主要用于监控对象是否已经被垃圾回收器标记为即将回收的垃圾，可以通过弱引用的isEnQueued方法返回对象是否被垃圾回收器标记。\n\n``` Java\n    public static void main(String[] args) {\n        String str = new String(\"abc\");\n        WeakReference<String> weakReference = new WeakReference<>(str);\n        System.out.println(\"1str: \" + str + \" weakReference>>: \" + weakReference.get());\n        str = null;\n        System.out.println(\"2str: \" + str + \" weakReference>>: \" + weakReference.get());\n        System.gc();\n        System.out.println(\"3str: \" + str + \" weakReference>>: \" + weakReference.get());\n    }\n\n//输出\n1str: abc weakReference>>: abc\n2str: null weakReference>>: abc\n3str: null weakReference>>: null\n```\n\n如果一个对象是偶尔(很少)的使用，并且希望在使用时随时就能获取到，但又不想影响此对象的垃圾收集，那么你应该用Weak Reference来记住此对象\n\n> Java中的ThreadLocal内部实现使用的就是WeakReference，因为weakReference的值可能为空，故在使用ThreadLocal时可以使用其提供的initialValue方法\n\n## 软引用VS弱引用\n\n软引用关联的对象只有在内存不足时才会被回收，而被弱引用关联的对象在JVM进行垃圾回收时总会被回收。\n\n``` Java\n/**\n * 软引用测试类\n * jvm参数， -Xms5m -Xmx10m表示初始内存是5M，最大内存是10M\n * -Xmx256m\n * @author jone.sun\n * @date 2020-11-30 11:12\n */\npublic class ReferenceTest {\n\n    private static List<Object> list = new ArrayList<>();\n\n    private static final Integer COUNT = 10;\n\n    public static void main(String[] args) {\n//        testFinalReference();\n//        testSoftReference();\n        testWeakReference();\n\n        print();\n        //手动调用gc\n        System.gc();\n        System.out.println(\"调用gc后\");\n        print();\n    }\n\n    /**\n     * 测试强引用\n     */\n    private static void testFinalReference() {\n        list.clear();\n        //我本机测试时 count为3就会报java.lang.OutOfMemoryError: Java heap space\n        for (int i = 0; i < COUNT; i++) {\n            //每次申请1M\n            list.add(new byte[1024 * 1024]);\n        }\n        System.out.println(\"list: \" + list.size());\n\n    }\n\n\n    /**\n     * 测试软引用\n     */\n    private static void testSoftReference() {\n        list.clear();\n        //可以随机添加，但最多只会保留两个，其他会被设置为null\n        for (int i = 0; i < COUNT; i++) {\n            byte[] buff = new byte[1024 * 1024];\n            SoftReference<byte[]> sr = new SoftReference<>(buff);\n            //注意这里是将data置为null之后，否则data是存在强引用关系的，软引用亦是如此。\n            buff = null;\n            list.add(sr);\n        }\n        System.out.println(\"list: \" + list.size());\n    }\n\n    /**\n     * 测试弱引用\n     */\n    private static void testWeakReference() {\n        list.clear();\n        //可以随机添加，但最多只会保留两个，其他会被设置为null\n        for (int i = 0; i < COUNT; i++) {\n            byte[] buff = new byte[1024 * 1024];\n            WeakReference<byte[]> sr = new WeakReference<>(buff);\n            buff = null;\n            list.add(sr);\n        }\n        System.out.println(\"list: \" + list.size());\n    }\n\n    private static void print() {\n        for(int i=0; i < list.size(); i++){\n            Object obj = list.get(i);\n            if(obj instanceof SoftReference) {\n                System.out.println(\"SoftReference: \" + i + \"= \" +  ((SoftReference)obj).get());\n            } else if(obj instanceof WeakReference) {\n                System.out.println(\"WeakReference: \" + i + \"= \" +  ((WeakReference)obj).get());\n            }\n            else {\n                System.out.println(i + \"= \" + obj);\n            }\n        }\n\n    }\n\n}\n\n//输出 可以发现SoftReference无论是否调用gc总是会有值，WeakReference使用后再调用gc就会设置为null\n```\n\n> 在使用软引用和弱引用的时候，可以显示地通过System.gc()来通知JVM进行垃圾回收，但是要注意的是，虽然发出了通知，JVM不一定会立刻执行，也就是说这句是无法确保此时JVM一定会进行垃圾回收的。\n\n## 虚引用\n\n虚引用是所有类型中最弱的一个。一个持有虚引用的对象和没有引用几乎是一样的，随时可能被垃圾回收器回收，当试图通过虚引用的get()方法取得强引用时，总是会失败。\n\n虚引用必须和引用队列一起使用，它的作用在于检测对象是否已经从内存中删除，跟踪垃圾回收过程。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在垃圾回收后，销毁这个对象，将这个虚引用加入引用队列。程序可以通过判断引用队列中是否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收。如果程序发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取必要的行动。\n\n类型 | 回收时间 | 使用场景\n---|---|---\n强引用 | 一直存活 | \t所有程序的场景，基本对象，自定义对象等。\n软引用SoftReference | 内存不足时会被回收 | \t一般用在对内存非常敏感的资源上，用作缓存的场景比较多，例如：网页缓存、图片缓存\n弱引用WeakReference | 只能存活到下一次GC前 | \t生命周期很短的对象，例如ThreadLocal中的Key。\n虚引用 | 随时会被回收， 创建了可能很快就会被回 | \t业界暂无使用场景， 可能被JVM团队内部用来跟踪JVM的垃圾回收活动\n\n\n# 引用队列（ReferenceQueue）\n\n官方对于引用队列类的注释是：\n\n> Reference queues, to which registered reference objects are appended by the garbage collector after the appropriate reachability changes are detected. 译为：引用队列是将垃圾收集器在监测到适当的可达性更改后将已注册的引用对象添加到该队列。\n\n对于软引用和弱引用和虚引用，我们希望**当一个对象被gc掉的时候通知用户线程，进行额外的处理时**，就需要使用引用队列了。ReferenceQueue即这样的一个对象，当一个obj被gc掉之后，其相应的包装类，即ref对象会被放入queue中。我们可以从queue中获取到相应的对象信息，同时进行额外的处理。比如反向操作，数据清理等:\n\n``` Java\nSoftReference ref = null;\nwhile ((ref = (EmployeeRef) q.poll()) != null) {\n// 清除ref\n}\n```\n\n实际上ReferenceQueue只是名义上的引用队列，它只保存了Reference链表的头(head)节点，并且提供了队列出队入队删除操作，而Reference实际上本身提供单向链表的功能，也就是说Reference通过成员属性next构建单向链表，而链表的操作是委托给ReferenceQueue完成。\n\n``` Java\npublic class SoftReferenceTest {\n\n\n    static class HeapObject {\n        byte[] bs = new byte[1024 * 1024];\n    }\n\n    public static void main(String[] args) {\n        ReferenceQueue<HeapObject> queue = new ReferenceQueue<>();\n        SoftReference<HeapObject> softReference = new SoftReference<>(new HeapObject(),queue);\n\n        List<HeapObject> list = new ArrayList<>();\n\n        while (true) {\n            if (softReference.get() != null) {\n                list.add(new HeapObject());\n                System.out.println(\"list.add\");\n            } else {\n                System.out.println(\"---------软引用已被回收---------\");\n                break;\n            }\n            System.gc();\n        }\n        Reference<? extends  HeapObject> pollRef = queue.poll();\n        while (pollRef != null) {\n            System.out.println(pollRef);\n            System.out.println(pollRef.get());\n            pollRef = queue.poll();\n        }\n    }\n}\n```\n\n设置VM options:-Xms5m -Xmx5m -XX:+PrintGC\n\n``` Java\nbyte[] data = new byte[1*1024*1024];\nReferenceQueue<Object> referenceQueue = new ReferenceQueue<>();\nSoftReference<byte[]> softReference = new SoftReference<>(data,referenceQueue);\ndata = null;\nSystem.out.println(\"before:\"+softReference.get());\n\ntry {\n    for (int i = 0; i < 10; i++) {\n        byte[] temp = new byte[3*1024*1024];\n        System.out.println(\"processing:\"+softReference.get());\n    }\n} catch (Throwable t) {\n    System.out.println(\"after:\"+softReference.get());\n    t.printStackTrace();\n}\nwhile(referenceQueue.poll()!=null){\n    System.out.println(\"self:\"+softReference);\n    softReference.clear();\n    softReference = null;\n    System.out.println(\"last:\"+softReference);\n}\n\n```\n\n> ReferenceQueue引用队列用来记录被回收的引用为用户线程做额外操作作铺垫\n\n# VisualVM使用\n\nVisualVM是集成JDK命令行工具和轻量级分析功能的可视化分析工具，设计用于开发和生产时间的使用。它提供了一个可视化界面，用于查看基于Java技术、运行于JVM上的应用程序(Java应用程序)的详细信息。\n\noracle版本的JDK 6〜8默认在bin目录下的jvisualvm.exe, 从Oracle JDK 9中开始已经不再内置visualvm(openjdk默认也是不包含的), 可以自己下载安装\n\n## 下载安装\n\n官网下载[最新版本](https://visualvm.github.io/releases.html)\n\n直接双击打开bin目录下的visualvm.exe\n\n> 如果出现cannot find java 1.8 or higher等问题的话, 则需要在etc目录下的visualvm.conf文件中加入jdk的目录，如：\n\n```\nvisualvm_jdkhome=\"C:\\Users\\jone.sun\\.jdks\\adopt-openjdk-1.8.0_275\"\n```\n\n### IDEA中使用\n\n打开IDEA的插件设置页面，搜索VisualVM Launcher，进行安装\n\n![VisualVM Launcher](VisualVM Launcher.png)\n\n完毕后即可通过IDEA启动VisualVM和自己的应用程序, 初次使用可能需要设置下路径:\n\n![VisualVM Launcher Setting](VisualVM Launcher Setting.png)\n\n之后就可以直接使用了![VisualVM Launcher Run](VisualVM Launcher Run.png)\n\n\n## 功能介绍\n\n### Sampler(抽样器)\n\n点击CPU，就可以看到各个类以及方法执行的时间，可以监控哪个类的方法执行时间较长，可以定位到具体的异常方法。\n\n点击内存，很直观的能找到哪个位置可能存在内存泄漏的情况。\n\n通过 Applications 窗口右击应用程序节点来启用\"Heap Dump on OOME(在出现 OOME 时生成堆 Dump)\"功能，当应用程序出现 OutOfMemory 例外时，VisualVM 将自动生成一个堆转储。\n\n> 除了监控本地的应用程序，同样可以远程监控局域网内的服务器","tags":["面试八股文","Java基础"],"categories":["Java","Java基础"]},{"title":"一款好用的Markdown编辑阅读器","url":"/2022/05/20/CmdMarkdown编辑器/","content":"# 欢迎使用 Cmd Markdown 编辑阅读器\n\n------\n\n我们理解您需要更便捷更高效的工具记录思想，整理笔记、知识，并将其中承载的价值传播给他人，**Cmd Markdown** 是我们给出的答案 —— 我们为记录思想和分享知识提供更专业的工具。 您可以使用 Cmd Markdown：\n\n> * 整理知识，学习笔记\n> * 发布日记，杂文，所见所想\n> * 撰写发布技术文稿（代码支持）\n> * 撰写发布学术论文（LaTeX 公式支持）\n\n![cmd-markdown-logo](https://www.zybuluo.com/static/img/logo.png)\n\n除了您现在看到的这个 Cmd Markdown 在线版本，您还可以前往以下网址下载：\n\n### [Windows/Mac/Linux 全平台客户端](https://www.zybuluo.com/cmd/)\n\n> 请保留此份 Cmd Markdown 的欢迎稿兼使用说明，如需撰写新稿件，点击顶部工具栏右侧的 <i class=\"icon-file\"></i> **新文稿** 或者使用快捷键 `Ctrl+Alt+N`。\n\n------\n\n## 什么是 Markdown\n\nMarkdown 是一种方便记忆、书写的纯文本标记语言，用户可以使用这些标记符号以最小的输入代价生成极富表现力的文档：譬如您正在阅读的这份文档。它使用简单的符号标记不同的标题，分割不同的段落，**粗体** 或者 *斜体* 某些文字，更棒的是，它还可以\n\n### 1. 制作一份待办事宜 [Todo 列表](https://www.zybuluo.com/mdeditor?url=https://www.zybuluo.com/static/editor/md-help.markdown#13-待办事宜-todo-列表)\n\n- [ ] 支持以 PDF 格式导出文稿\n- [ ] 改进 Cmd 渲染算法，使用局部渲染技术提高渲染效率\n- [x] 新增 Todo 列表功能\n- [x] 修复 LaTex 公式渲染问题\n- [x] 新增 LaTex 公式编号功能\n\n### 2. 书写一个质能守恒公式[^LaTeX]\n\n$$E=mc^2$$\n\n### 3. 高亮一段代码[^code]\n\n```python\n@requires_authorization\nclass SomeClass:\n    pass\n\nif __name__ == '__main__':\n    # A comment\n    print 'hello world'\n```\n\n### 4. 高效绘制 [流程图](https://www.zybuluo.com/mdeditor?url=https://www.zybuluo.com/static/editor/md-help.markdown#7-流程图)\n\n```flow\nst=>start: Start\nop=>operation: Your Operation\ncond=>condition: Yes or No?\ne=>end\n\nst->op->cond\ncond(yes)->e\ncond(no)->op\n```\n\n### 5. 高效绘制 [序列图](https://www.zybuluo.com/mdeditor?url=https://www.zybuluo.com/static/editor/md-help.markdown#8-序列图)\n\n```seq\nAlice->Bob: Hello Bob, how are you?\nNote right of Bob: Bob thinks\nBob-->Alice: I am good thanks!\n```\n\n### 6. 高效绘制 [甘特图](https://www.zybuluo.com/mdeditor?url=https://www.zybuluo.com/static/editor/md-help.markdown#9-甘特图)\n\n```gantt\n    title 项目开发流程\n    section 项目确定\n        需求分析       :a1, 2016-06-22, 3d\n        可行性报告     :after a1, 5d\n        概念验证       : 5d\n    section 项目实施\n        概要设计      :2016-07-05  , 5d\n        详细设计      :2016-07-08, 10d\n        编码          :2016-07-15, 10d\n        测试          :2016-07-22, 5d\n    section 发布验收\n        发布: 2d\n        验收: 3d\n```\n\n### 7. 绘制表格\n\n| 项目        | 价格   |  数量  |\n| --------   | -----:  | :----:  |\n| 计算机     | \\$1600 |   5     |\n| 手机        |   \\$12   |   12   |\n| 管线        |    \\$1    |  234  |\n\n### 8. 更详细语法说明\n\n想要查看更详细的语法说明，可以参考我们准备的 [Cmd Markdown 简明语法手册][1]，进阶用户可以参考 [Cmd Markdown 高阶语法手册][2] 了解更多高级功能。\n\n总而言之，不同于其它 *所见即所得* 的编辑器：你只需使用键盘专注于书写文本内容，就可以生成印刷级的排版格式，省却在键盘和工具栏之间来回切换，调整内容和格式的麻烦。**Markdown 在流畅的书写和印刷级的阅读体验之间找到了平衡。** 目前它已经成为世界上最大的技术分享网站 GitHub 和 技术问答网站 StackOverFlow 的御用书写格式。\n\n---\n\n## 什么是 Cmd Markdown\n\n您可以使用很多工具书写 Markdown，但是 Cmd Markdown 是这个星球上我们已知的、最好的 Markdown 工具——没有之一 ：）因为深信文字的力量，所以我们和你一样，对流畅书写，分享思想和知识，以及阅读体验有极致的追求，我们把对于这些诉求的回应整合在 Cmd Markdown，并且一次，两次，三次，乃至无数次地提升这个工具的体验，最终将它演化成一个 **编辑/发布/阅读** Markdown 的在线平台——您可以在任何地方，任何系统/设备上管理这里的文字。\n\n### 1. 实时同步预览\n\n我们将 Cmd Markdown 的主界面一分为二，左边为**编辑区**，右边为**预览区**，在编辑区的操作会实时地渲染到预览区方便查看最终的版面效果，并且如果你在其中一个区拖动滚动条，我们有一个巧妙的算法把另一个区的滚动条同步到等价的位置，超酷！\n\n### 2. 编辑工具栏\n\n也许您还是一个 Markdown 语法的新手，在您完全熟悉它之前，我们在 **编辑区** 的顶部放置了一个如下图所示的工具栏，您可以使用鼠标在工具栏上调整格式，不过我们仍旧鼓励你使用键盘标记格式，提高书写的流畅度。\n\n![tool-editor](https://www.zybuluo.com/static/img/toolbar-editor.png)\n\n### 3. 编辑模式\n\n完全心无旁骛的方式编辑文字：点击 **编辑工具栏** 最右侧的拉伸按钮或者按下 `Ctrl + M`，将 Cmd Markdown 切换到独立的编辑模式，这是一个极度简洁的写作环境，所有可能会引起分心的元素都已经被挪除，超清爽！\n\n### 4. 实时的云端文稿\n\n为了保障数据安全，Cmd Markdown 会将您每一次击键的内容保存至云端，同时在 **编辑工具栏** 的最右侧提示 `已保存` 的字样。无需担心浏览器崩溃，机器掉电或者地震，海啸——在编辑的过程中随时关闭浏览器或者机器，下一次回到 Cmd Markdown 的时候继续写作。\n\n### 5. 离线模式\n\n在网络环境不稳定的情况下记录文字一样很安全！在您写作的时候，如果电脑突然失去网络连接，Cmd Markdown 会智能切换至离线模式，将您后续键入的文字保存在本地，直到网络恢复再将他们传送至云端，即使在网络恢复前关闭浏览器或者电脑，一样没有问题，等到下次开启 Cmd Markdown 的时候，她会提醒您将离线保存的文字传送至云端。简而言之，我们尽最大的努力保障您文字的安全。\n\n### 6. 管理工具栏\n\n为了便于管理您的文稿，在 **预览区** 的顶部放置了如下所示的 **管理工具栏**：\n\n![tool-manager](https://www.zybuluo.com/static/img/toolbar-manager.jpg)\n\n通过管理工具栏可以：\n\n<i class=\"icon-share\"></i> 发布：将当前的文稿生成固定链接，在网络上发布，分享\n<i class=\"icon-file\"></i> 新建：开始撰写一篇新的文稿\n<i class=\"icon-trash\"></i> 删除：删除当前的文稿\n<i class=\"icon-cloud\"></i> 导出：将当前的文稿转化为 Markdown 文本或者 Html 格式，并导出到本地\n<i class=\"icon-reorder\"></i> 列表：所有新增和过往的文稿都可以在这里查看、操作\n<i class=\"icon-pencil\"></i> 模式：切换 普通/Vim/Emacs 编辑模式\n\n### 7. 阅读工具栏\n\n![tool-manager](https://www.zybuluo.com/static/img/toolbar-reader.jpg)\n\n通过 **预览区** 右上角的 **阅读工具栏**，可以查看当前文稿的目录并增强阅读体验。\n\n工具栏上的五个图标依次为：\n\n<i class=\"icon-list\"></i> 目录：快速导航当前文稿的目录结构以跳转到感兴趣的段落\n<i class=\"icon-chevron-sign-left\"></i> 视图：互换左边编辑区和右边预览区的位置\n<i class=\"icon-adjust\"></i> 主题：内置了黑白两种模式的主题，试试 **黑色主题**，超炫！\n<i class=\"icon-desktop\"></i> 阅读：心无旁骛的阅读模式提供超一流的阅读体验\n<i class=\"icon-fullscreen\"></i> 全屏：简洁，简洁，再简洁，一个完全沉浸式的写作和阅读环境\n\n### 8. 阅读模式\n\n在 **阅读工具栏** 点击 <i class=\"icon-desktop\"></i> 或者按下 `Ctrl+Alt+M` 随即进入独立的阅读模式界面，我们在版面渲染上的每一个细节：字体，字号，行间距，前背景色都倾注了大量的时间，努力提升阅读的体验和品质。\n\n### 9. 标签、分类和搜索\n\n在编辑区任意行首位置输入以下格式的文字可以标签当前文档：\n\n标签： 未分类\n\n标签以后的文稿在【文件列表】（Ctrl+Alt+F）里会按照标签分类，用户可以同时使用键盘或者鼠标浏览查看，或者在【文件列表】的搜索文本框内搜索标题关键字过滤文稿，如下图所示：\n\n![file-list](https://www.zybuluo.com/static/img/file-list.png)\n\n### 10. 文稿发布和分享\n\n在您使用 Cmd Markdown 记录，创作，整理，阅读文稿的同时，我们不仅希望它是一个有力的工具，更希望您的思想和知识通过这个平台，连同优质的阅读体验，将他们分享给有相同志趣的人，进而鼓励更多的人来到这里记录分享他们的思想和知识，尝试点击 <i class=\"icon-share\"></i> (Ctrl+Alt+P) 发布这份文档给好友吧！\n\n------\n\n再一次感谢您花费时间阅读这份欢迎稿，点击 <i class=\"icon-file\"></i> (Ctrl+Alt+N) 开始撰写新的文稿吧！祝您在这里记录、阅读、分享愉快！\n\n作者 [@ghosert][3]     \n2016 年 07月 07日\n\n[^LaTeX]: 支持 **LaTeX** 编辑显示支持，例如：$\\sum_{i=1}^n a_i=0$， 访问 [MathJax][4] 参考更多使用方法。\n\n[^code]: 代码高亮功能支持包括 Java, Python, JavaScript 在内的，**四十一**种主流编程语言。\n\n[1]: https://www.zybuluo.com/mdeditor?url=https://www.zybuluo.com/static/editor/md-help.markdown\n[2]: https://www.zybuluo.com/mdeditor?url=https://www.zybuluo.com/static/editor/md-help.markdown#cmd-markdown-高阶语法手册\n[3]: http://weibo.com/ghosert\n[4]: http://meta.math.stackexchange.com/questions/5020/mathjax-basic-tutorial-and-quick-reference\n\n","tags":["软件分享"],"categories":["杂七杂八","软件安利"]}]